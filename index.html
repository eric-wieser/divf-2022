<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="reveal.js/dist/reset.css" />
  <link rel="stylesheet" href="reveal.js/dist/reveal.css" />
  <link rel="stylesheet" href="reveal.js/dist/theme/white.css" />
  <link rel="stylesheet" href="css/hljs.css" />
  <link rel="stylesheet" href="css/common.css" />
  <link rel="shortcut icon" type="image/png" href="https://ericwieser.me/images/favicon.png"/>
  <meta name="author" content="Eric Wieser" />
  <meta name="description" content="
    Working with noncommutative algebras in computer algebra systems (CAS) can be challenging.
    Taking a popular CAS as an example; Python's sympy can run into various difficulties when working with the matrix and quaternion algebras, and building more unusual algebras only makes matters worse.
    While on the surface solving a similar class of problems to CAS, theorem provers offer a very strong correctness guarantee.
    As it turns out, the design decisions that ensure this guarantee are the same as those which provide the extensionality needed for adding new algebraic constructions.
    With this background, this talk acts as an introduction to the Lean theorem prover by example, and demonstrates some of the trade-offs to be made by choosing to use a theorem prover over a CAS.
    With the help of Lean's comprehensive library of formalized mathematics, Mathlib, I'll show how to manipulate and simplify some matrix expressions.
    Lean and Mathlib are a collaborative effort; this talk concludes with a summary of the more interesting parts I myself have contributed." />
  <meta name="keywords" content="sympy, lean, non-commutative algebra, mathlib" />
  <title>Non-commutative algebras, computer algebra systems, and theorem provers</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <section style="height: var(--slide-height)">
          <div style="display: grid; align-items: center; height: 100%">
            <div>
              <h1 style="font-size: 2em">Non-commutative algebras,<br />computer algebra systems,<br />and theorem provers</h1>

              <p>Eric Wieser<br/> Signal Processing Group</p>
              <small>slides: <a href="https://eric-wieser.github.io/divf-2022">
              eric-wieser.github.io/divf-2022</a></small>
              <small style="display: block; text-align: center; opacity: 0.5">2022-03-25</small>
            </div>
          </div>
        </section>
      </section>
      <section>
        <section style="height: var(--slide-height)">
          <div style="display: grid; align-items: center; height: 100%">
            <div>
              <h2>Non-commutative algebras</h2>
              <div style="font-size: 2em; opacity: 0.6">$$ab \ne ba$$</div>
            </div>
          </div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Non-commutative algebras</span> Geometric motivation</div></h3>
          <div class="r-stretch" style="display: grid; align-items: center">
            <div class="grid" style="grid-template: auto / 1fr 1fr; text-align: left">
              <div>
                <p>Geometry is inherently non-commutative:</p>
                <ul>
                  <li>applying 3D rotations in a different order gives a different result</li>
                  <li>the oriented plane spanning $u$ and $v$ faces the opposite way to the one spanning $v$ and $u$</li>
                </ul>
              </div>
              <div>
                <p>&hellip; algebraic representations of geometry are too:</p>
                <ul>
                  <li>for rotation matrices, composition is multiplication, and $R_1R_2 \ne R_2R_1$ in general<br /></li>
                  <li>the normal vector of such a plane (in 3D) can be found with the cross product, and $u\times v = -v\times u$.</li>
                </ul>
              </div>
            </div>
          </div>
          <p style="text-align: left">
            The matrix algebra $\mathbb{R}^{n \times n}$ is the typical choice for representing geometry, but is by no means the only choice available:
          </p>
          <div class="grid" style="grid-template: 1fr / auto auto auto">
            <p>Quaternions<br />$\mathbb{H}$</p>
            <p>Exterior algebra<br />$\bigwedge(V)$</p>
            <p>Geometric algebra<br />$\mathcal{G}(Q)$</p>
          </div>
        </section>
        <section id="noncommutative-geometric" data-auto-animate>
          <h3><div class="parent-title"><span>Non-commutative algebras</span> Geometric examples</div></h3>
          <h4>Quaternions, $\mathbb{H}$</h4>
          <div style="text-align: left; margin-left: auto; margin-right: auto;" class="fragment">
            <p>Like the complex numbers, $q = r + x\mathrm{i} + y\mathrm{j} + z\mathrm{k}$, but with $i^2 = j^2 = k^2 = ijk = −1$.</p>
            <p>In 3D, a rotation around the axis $u$ by $\theta$ can be represented as:</p>
            $$e^{\frac{\theta}{2}{(u_x\mathrm{i} + u_y\mathrm{j} + u_z\mathrm{k})}} = \cos \frac{\theta}{2} + (u_x\mathrm{i} + u_y\mathrm{j} + u_z\mathrm{k}) \sin \frac{\theta}{2}$$
            <p>Applying a quaternion rotation is done as $qvq^{-1}$.</p>
            <p>Every (normed) quaternion represents a rotation; typically a better choice than rotation matrices which can become non-orthonormal.</p>
            <p>A division ring, unlike the matrix algebra; all non-zero quaternions have an inverse.</p>
          </div>
          <h4 style="opacity: 0.5" data-id="exterior_heading">Exterior algebra, $\bigwedge(V)$</h4>
          <h4 style="opacity: 0.5" data-id="geometric_heading">Geometric algebra, $\mathcal{G}(Q)$</h4>
        </section>
        <section id="noncommutative-geometric-2" data-auto-animate>
          <h3><div class="parent-title"><span>Non-commutative algebras</span> Geometric examples</div></h3>
          <h4 style="opacity: 0.5">Quaternions, $\mathbb{H}$</h4>
          <h4 data-id="exterior_heading">Exterior&nbsp;algebra, $\bigwedge(V)$</h4>
          <div style="text-align: left" class="fragment">
            <p>For an arbitrary vector space $V$ containing $u, v$, $u \wedge v = -v \wedge u$ represents an oriented plane at the origin spanning $u$ then $v$.</p>
            <p>Unlike the cross product, generalizes to higher dimensions: $u \wedge v \wedge w$ is an oriented volume.</p>
          </div>
          <h4 data-id="geometric_heading">Geometric&nbsp;algebra, $\mathcal{G}(Q)$</h4>
          <div style="text-align: left" class="fragment">
            <p>An extension of exterior algebra that includes a metric $Q$, which result in a dot product.</p>
            <p>Multiplication of vectors satisfies:</p>
            $$uv = u\cdot v + u \wedge v$$
          </div>
        </section>
        <section id="weaker-algebraic-structures">
          <h3><div class="parent-title"><span>Non-commutative algebras</span>Weaker algebraic structures</div></h3>
          <dl>
            <dt class="fragment fade-in-then-semi-out" data-fragment-index="0">$ab \ne ba$; non-commutativity</dt>
            <dd class="fragment fade-in-then-semi-out" data-fragment-index="0">
              <p>As we saw, this is particularly easy to motivate through geometry. This paves the way to further <q>weakening</q> of our algebraic rules.</p>
            </dd>
            <dt class="fragment fade-in-then-semi-out" data-fragment-index="1">$a \ne 0, b \ne 0, ab = 0$; zero divisors</dt>
            <dd class="fragment fade-in-then-semi-out" data-fragment-index="1">
              <p>$\mathbb{R}^{n \times n}$ and $\bigwedge(B)$ and $\mathcal{G}(Q)$ all have this property.</p>
              <p>This means $ab = ac \centernot\implies b = c$!</p>
            </dd>
            <dt class="fragment fade-in-then-semi-out" data-fragment-index="2">$a(bc) \ne (ab)c$; non-associativity</dt>
            <dd class="fragment fade-in-then-semi-out" data-fragment-index="2">
              <p>A simple example is the vector cross product:</p>
              $$u \times (v \times w) = (u \times v) \times w + v \times (u \times w)$$
              <p>More examples: Lie algebras, Octonions, &hellip;</p>
            </dd>
          </dl>
          <p class="fragment" data-fragment-index="3">
            Forgetting these weaknesses leads to algebraic mistakes.</p>
          <p class="fragment" data-fragment-index="4">
            Can we software help us keep track of them?</p>
        </section>
      </section>
      <section>
        <section id="computer-algebra">
          <h2>Computer algebra systems</h2>
          <blockquote>
            A computer algebra system (CAS) or symbolic algebra system (SAS) is any mathematical software with the ability to manipulate mathematical expressions in a way similar to the traditional manual computations of mathematicians and scientists.
            <p class="reference">
              <cite><a href="https://en.wikipedia.org/wiki/Computer_algebra_system">Computer algebra system</a></cite>
              <span>Wikipedia</span>
            </p>
          </blockquote>
          <div class="grid" style="grid-template: auto / 1fr 1fr;">
            <div>
              <p>Useful for</p>
              <ul style="font-size: 0.8em">
                <li>Roughly checking your work</li>
                <li>Answering what-if questions experimentally</li>
                <li>Solving large but tedious equations quickly</li>
                <li>&hellip;</li>
              </ul>
            </div>
            <div>
              <p>Typical features</p>
              <ul style="font-size: 0.8em">
                <li>Algebraic simplification</li>
                <li>Root finding</li>
                <li>Integration and differentiation</li>
                <li>Arbitrary precision calculations</li>
                <li>&hellip;</li>
              </ul>
            </div>
          </div>
          <div class="fragment">
            <p>Notable implementations</p>
            <div style="height:50px; position:relative; width: 90%; margin: auto; margin-bottom: 20px">
              <canvas id="cas-timeline"></canvas>
            </div>
            <div style="display: grid; grid-auto-flow: column">
              <div>Axiom<br /><small>(1965, BSD)</small></div>
              <div>Maxima<br /><small>(1982, GPL)</small></div>
              <div>Maple<br /><small>(1982, Proprietary)</small></div>
              <div>Magma<br /><small>(1993, Proprietary)</small> </div>
              <div>Mathematica<br /><small>(1998, Proprietary)</small></div>
              <div>SageMath<br /><small>(2004, GPL)</small></div>
            </div>
          </div>
        </section>
        <section id="sympy">
          <h2>Sympy</h2>
          <blockquote>
            SymPy is a Python library for symbolic mathematics. It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python.
            <p class="reference">
              <cite><a href="https://www.sympy.org/en/index.html">SymPy's website</a></cite>
              <!-- <span>Sympy.org</span> -->
            </p>
          </blockquote>
          <p class="fragment" style="text-align: center">Why wasn't this on the previous slide?</p>
          <blockquote class="fragment">
            Sage[Math] tries to gather together all the major open source mathematics software, and glue it together into a useful system. In fact, Sage[Math] includes SymPy as one of its systems.
            <p class="reference">
              <cite><a href="https://stackoverflow.com/q/17847902/102441">What is the difference between SymPy and Sage[Math]?</a></cite>
              <span>Aaron Meurer (Lead SymPy developer)</span>
            </p>
          </blockquote>
        </section>
        <section id="sympy-examples">
          <h3><div class="parent-title"><span>Sympy</span> Examples</div></h3>
          <blockquote>
            <div class="grid" style="align-items: end">
              <div>
                <p>Solve $x^2 - 2 = 0$</p>
                <pre><code class="pycon" data-trim data-no-escape>
                &gt;&gt;&gt; solve(x**2 - 2, x)
                $\left[ - \sqrt{2}, \  \sqrt{2}\right]$
                </code></pre>
              </div>
              <div>
                <p>Take the derivative of $\sin{(x)}e^x$</p>
                <pre><code class="pycon" data-trim data-no-escape>
                &gt;&gt;&gt; diff(sin(x)*exp(x), x)
                $e^{x} \sin{\left(x \right)} + e^{x} \cos{\left(x \right)}$
                </code></pre>
              </div>
              <div>
                <p>Compute $\int_{-\infty}^\infty \sin{(x^2)}\,dx$</p>
                <pre><code class="pycon" data-trim data-no-escape>
                &gt;&gt;&gt; integrate(exp(x)*sin(x) + exp(x)*cos(x), x)
                $e^{x} \sin{\left(x \right)}$
                </code></pre>
              </div>
              <div>
                <p>Solve the differential equation $y'' - y = e^t$</p>
                <pre><code class="pycon" data-trim data-no-escape>
                  &gt;&gt;&gt; y = Function('y')
                  &gt;&gt;&gt; dsolve(Eq(y(t).diff(t, t) - y(t), exp(t)), y(t))
                  $y{\left(t \right)} = C_{2} e^{- t} + \left(C_{1} + \frac{t}{2}\right) e^{t}$
                </code></pre>
              </div>
            </div>
            <p class="reference">
              <cite><a href="https://docs.sympy.org/latest/tutorial/intro.html#the-power-of-symbolic-computation">
                The Power of Symbolic Computation
              </a></cite>
              <span>SymPy.org</span>
            </p>
          </blockquote>
        </section>
        <section id="sympy-expression-trees" data-auto-animate>
          <h3><div class="parent-title"><span>Sympy</span>Expression trees</div></h3>
          <pre><code class="pycon" data-trim>
          >>> from sympy import *; from this_presentation import show_repr
          </code></pre>
          <div style="display: grid; grid-template: auto auto / 1fr 1fr; column-gap: var(--r-block-margin)">
            <div class="fragment" data-fragment-index="1">
              <h4>Real numbers</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; x, y = symbols('x y', real=True)
              &gt;&gt;&gt; expr = (x + y)*(x - y); expr
              $(x - y)(x + y)$
              <span class="fragment" data-fragment-index="2">&gt;&gt;&gt; show_repr(expr)
              Mul(Add($x$, Mul(Integer(-1), $y$)),
                  Add($x$, $y$))</span>
              </code></pre>
            </div>
            <div class="fragment" data-fragment-index="3">
              <h4>Complex numbers</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; x, y = symbols('x y', complex=True)
              &gt;&gt;&gt; expr = (x + y)*(x - y); expr
              $(x - y)(x + y)$
              <span class="fragment" data-fragment-index="4">&gt;&gt;&gt; show_repr(expr)
              Mul(Add($x$, Mul(Integer(-1), $y$)),
                  Add($x$, $y$))</span>
              </code></pre>
            </div>
            <div>
              <h4 class="fragment" data-fragment-index="2">
                Underlying representations
              </h4>
              <dl>
                <dt class="fragment" data-fragment-index="2">Real</dt>
                <dd class="fragment" data-fragment-index="2"><code>Symbol</code>, <code>Add</code>, <code>Mul</code>, &hellip;</dd>
                <dt class="fragment" data-fragment-index="4">Complex</dt>
                <dd class="fragment" data-fragment-index="4"><code>Symbol</code>, <code>Add</code>, <code>Mul</code>, &hellip;</dd>
                <dt class="fragment" data-fragment-index="6">Matrix</dt>
                <dd class="fragment" data-fragment-index="6"><code>MatrixSymbol</code>, <code>MatAdd</code>, <code>MatMul</code>, &hellip;</dd>
                <dt class="fragment" data-fragment-index="7">Quaternions?</dt>
              </dl>
            </div>
            <div class="fragment" data-fragment-index="5">
              <h4>Matrices</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; m, n = symbols('m n')
              &gt;&gt;&gt; X = MatrixSymbol('X', m, n)
              &gt;&gt;&gt; Y = MatrixSymbol('Y', m, n)
              &gt;&gt;&gt; expr = (X + Y)*(X - Y).T; expr
              $(X + Y)(X^T - Y^T)$
              <span class="fragment" data-fragment-index="6">&gt;&gt;&gt; show_repr(expr)
              MatMul(
                  MatAdd($X$, $Y$),
                  MatAdd(
                      Transpose($X$),
                      MatMul(Integer(-1), Transpose($Y$))))</span>
              </code></pre>
            </div>
          </div>
        </section>
        <section id="sympy-expression-trees-2" data-auto-animate>
          <h3><div class="parent-title"><span>Sympy</span>Expression trees</div></h3>
          <div>
            <h4>Quaternions</h4>
            <p>No symbolic quaternions; only quaternions with symbolic coefficients.</p>
            <pre><code class="pycon" data-trim data-noescape>
            &gt;&gt;&gt; x, xi, xj, xk = symbols('x x_i x_j x_k');  xq = Quaternion(x, xi, xj, xk)
            &gt;&gt;&gt; y, yi, yj, yk = symbols('y y_i y_j y_k');  yq = Quaternion(y, yi, yj, yk)
            &gt;&gt;&gt; expr = xq * yq; expr
            $\left(x y - x_{i} y_{i} - x_{j} y_{j} - x_{k} y_{k}\right) + \left(x y_{i} + x_{i} y + x_{j} y_{k} - x_{k} y_{j}\right) i$
            $\quad+ \left(x y_{j} - x_{i} y_{k} + x_{j} y + x_{k} y_{i}\right) j + \left(x y_{k} + x_{i} y_{j} - x_{j} y_{i} + x_{k} y\right)$
            <span class="fragment">&gt;&gt;&gt; show_repr(expr)
            <span style="font-size: 80%; line-height: 1.3em">Quaternion(Add(Mul($x$, $y$), Mul(Integer(-1), $x_i$, $y_i$), Mul(Integer(-1), $x_j$, $y_j$), Mul(Integer(-1), $x_k$, $y_k$)),
                       Add(Mul($x$, $y_i$), Mul($x_i$, $y$), Mul($x_j$, $y_k$), Mul(Integer(-1), $x_k$, $y_j$)),
                       Add(Mul($x$, $y_j$), Mul(Integer(-1), $x_i$, $y_k$), Mul($x_j$, $y$), Mul($x_k$, $y_i$)),
                       Add(Mul($x$, $y_k$), Mul($x_i$, $y_j$), Mul(Integer(-1), $x_j$, $y_i$), Mul($x_k$, $y$)))</span></span>
            </code></pre>
          </div>
          <p class="fragment">This makes quaternions hard to work with:</p>
          <div class="grid" style="grid-template-columns: auto auto; align-items: center;">
            <div class="fragment"><p>$x_qx_qx_q^{-1}y_q = x_qy_q$</p></div>
            <div class="fragment">
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; (xq * xq * xq**-1 * yq).simplify()
              <div style="font-size: 80%; line-height: 1.3em">$\left(x y - x_{i} y_{i} - x_{j} y_{j} - x_{k} y_{k}\right) + \left(x y_{i} + x_{i} y + x_{j} y_{k} - x_{k} y_{j}\right) i$
              $\qquad + \left(x y_{j} - x_{i} y_{k} + x_{j} y + x_{k} y_{i}\right) j + \left(x y_{k} + x_{i} y_{j} - x_{j} y_{i} + x_{k} y\right) k$</div>
              </code></pre>
            </div>
            <div class="fragment"><p>$\nabla_{\!x_q}(x_qy_q) = -2y_q$</p></div>
            <div class="fragment">
              <pre style="font-size: 60%"><code class="pycon" data-trim data-noescape>
              <span style="opacity: 0.5">&gt;&gt;&gt; def q_diff(Φ, dq):  # similar to ∇Φ
              ...     ℍ = Quaternion
              ...     I,J,K = ℍ(0,1,0,0),ℍ(0,0,1,0),ℍ(0,0,0,1)
              ...     return (Φ.diff(dq.a) + I*Φ.diff(dq.b)
              ...         + J*Φ.diff(dq.c) + K*Φ.diff(dq.d))</span>
              &gt;&gt;&gt; q_diff(xq*yq, xq)
              $- 2 y + - 2 y_{i} i + - 2 y_{j} j + - 2 y_{k} k$
              </code></pre>
            </div>
          </div>
        </section>
        <section id="sympy-determinants">
          <h3><div class="parent-title"><span>Sympy</span>Examples with matrix determinants</div></h3>
          <div class="grid" style="grid-template-columns: auto auto auto;">
            <div>
              <pre><code class="pycon" data-trim>
              >>> m, n = symbols('m, n')
              </code></pre>
            </div>
            <div>
              <pre><code class="pycon" data-trim>
              >>> A = MatrixSymbol('A', n, n)
              >>> B = MatrixSymbol('B', n, n)
              </code></pre>
            </div>
            <div>
              <pre><code class="pycon" data-trim>
              >>> P = MatrixSymbol('P', m, n)
              >>> Q = MatrixSymbol('Q', n, m)
              </code></pre>
            </div>
          </div>
          <div class="grid" style="grid-template-columns: auto auto">
            <div data-fragment-index="0" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} AB = \operatorname{det} A \operatorname{det} B$$
              <pre><code class="pycon" data-trim>
              >>> Eq(det(A*B), det(A)*det(B))
              $\text{True}$
              </code></pre>
            </div>
            <div data-fragment-index="0"  class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code class="python">Eq</code> can be used to write down a symbolic equality.</p>
              <p><code class="python">MatMul._eval_determinant</code> is expanding the determinant for us.</p>
            </div>
            <div data-fragment-index="1"  class="fragment fade-in-then-semi-out">
              $$\operatorname{det} ABA^{-1} = \operatorname{det} B$$
              <pre><code class="pycon" data-trim>
              >>> Eq(det(A*B*A.inv()), det(B))
              $\left|{A^{-1}}\right| \left|{A}\right| \left|{B}\right| = \left|{B}\right|$
              >>> Eq(det(A*B*A.inv()), det(B)).simplify()
              $\text{True}$
              </code></pre>
            </div>
            <div data-fragment-index="1" class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code class="python">_eval_determinant</code> gets us partway there, but doesn't finish the job.</p>
              <p><code class="python">simplify()</code> can clean up.</p>
            </div>
            <div data-fragment-index="2" class="fragment">
              $$\operatorname{det} (I_m + PQ) = \operatorname{det} (I_n + QP)$$
              <small style="display: block; margin-top: -20px">(sometimes called the <q>Weinstein–Aronszajn</q> identity)</small>
              <pre class="r-stack"><code class="pycon fragment" data-trim data-fragment-index="2" >
              >>> I = Identity
              >>> Eq(det(I(m) + P*Q), det(I(n) + Q*P))
              $\left|{\mathbb{I} + PQ}\right| = \left|{\mathbb{I} + QP}\right|$
              >>> Eq(det(I(m) + P*Q),
              ...    det(I(n) + Q*P)).simplify()
              NonSquareMatrixError:
                Det of a non-square matrix
              </code><code class="pycon fragment" data-trim data-noescape data-fragment-index="3">
              &gt;&gt;&gt; I = Identity
              &gt;&gt;&gt; Eq(det(I(<b>n</b>) + A*B), det(I(n) + B*A))
              $\left|{\mathbb{I} + AB}\right| = \left|{\mathbb{I} + BA}\right|$
              &gt;&gt;&gt; Eq(det(I(<b>n</b>) + A*B),
              ...    det(I(n) + B*A)).simplify()
              AttributeError:
                'Mul' object has no attribute 'shape'
              </code></pre>
            </div>
            <div data-fragment-index="2" class="fragment" style="text-align: left">
              <p>There is no <code class="python">MatAdd._eval_determinant</code> to help here.</p>
              <p><code>simplify()</code> is ad-hoc, and sometimes crashes! <span class="fragment" data-fragment-index="3">Switching to square matrices makes things worse!</span></p>
            </div>
          </div>
        </section>
        <section id="sympy-problems">
          <h3><div class="parent-title"><span>Sympy</span>What's going wrong?</div></h3>
          <div class="fragment semi-fade-out" data-fragment-index="3">
            <p>Consider supporting a new algebra, <code>MyAlg</code>. We have two big hurdles:</p>
            <div class="grid" style="grid-template-columns: 1fr 1fr">
              <div class="fragment" data-fragment-index="0" >
                <h4 style="margin-top: var(--r-block-margin)">Expression tree extension</h4>
                <div style="text-align: left">
                  <p>It looks like we have to build new <code>MyAlgAdd</code>, <code>MyAlgMul</code>, &hellip; objects.</p>
                  <p>This scales poorly if we want to work with things like matrices of <code>MyAlg</code>; do we need <code>MatrixMyAlgAdd</code> e.t.c.?</p>
                  <p>If we get this wrong, things like <code>simplify()</code> fail if they expect <code>MyMul</code> but get an <code>Mul</code>.</p>
                </div>
              </div>
              <div class="fragment" data-fragment-index="1" >
                <h4 style="margin-top: var(--r-block-margin)">Supporting symbols</h4>
                <div style="text-align: left">
                  <p>Defining our objects as structures with fields like we would in a conventional programming language isn't enough.</p>
                  <p>Expression tree objects needs to know how to simplify themselves.</p>
                  <p>This local simplification doesn't scale to things like $\operatorname{det}(1 + AB) = \operatorname{det}(1 + BA)$.</p>
                </div>
              </div>
            </div>
            <p class="fragment" data-fragment-index="2"><strong>Are we sure our simplifications are mathematically sound?</strong></p>
          </div>
          <p class="fragment" data-fragment-index="3">What if our programming language could handle all of this?</p>
        </section>
      </section>
      <section>
        <section>
          <h3>What is a theorem prover?</h3>
          <blockquote>
            <p>A proof assistant [or theorem prover] is a piece of software that provides a language for defining objects, specifying properties of these objects, and proving that these specifications hold. The system checks that these proofs are correct down to their logical foundation.</p>

            <p>These tools are often used to verify the correctness of programs. But they can also be used for abstract mathematics [...]. In a formalization, all definitions are precisely specified and all proofs are virtually guaranteed to be correct.</p>
            <p class="reference">
              <cite><a href="https://leanprover-community.github.io/#what-is-a-proof-assistant">What is a proof assistant?</a></cite>
              <span>Lean community website</span>
            </p>
          </blockquote>
        </section>
        <!-- TODO: add a summary slide of what theorem provers do? -->
        <section>
          <h2>Theorem proving languages - History</h2>
          <div style="height:50px; position:relative; width: 90%; margin: auto; margin-bottom: 20px">
            <canvas id="lean-timeline"></canvas>
          </div>
          <ul>
            <li class="fragment">Relatively new (compared to other actively used tools)
              <ul>
                <li style="font-size: smaller">Mizar (<span style="color: #42affa">1973</span>), Isabelle (<span style="color: #42affa">1986</span>), HOL Family (<span style="color: #42affa">1988</span>)</li>
                <li style="font-size: smaller">Coq (<span style="color: #42affa">1989</span>), Metamath (<span style="color: #42affa">1993</span>), Agda (<span style="color: #42affa">2007</span>)</li>
                <li style="font-size: smaller">Lean 1 (<span style="color: green">2013</span>) & Lean 2 (<span style="color: green">2015</span>)</li>
              </ul>
              <blockquote>
                Lean had the advantage of being born later and learning from past mistakes.
                <p class="reference">
                  <cite>CICM 2020 slack</cite>
                  <span>Mario Carneiro, Lean Maintainer</span>
                </p>
              </blockquote>
            </li>
            <li class="fragment">Lean 3 (<span style="color: green">2016</span>)
              <ul>
                <li style="font-size: smaller">Actively maintained by the community (v3.24.0 to v3.35.1 in 2021)</li>
                <li style="font-size: smaller">Can be used <a href="https://leanprover.github.io/live/latest/">in-browser</a> or in supported IDEs: <a href="https://github.com/leanprover/vscode-lean">VS Code</a> and <a href="https://github.com/leanprover/lean-mode">Emacs</a></li>
              </ul>
            </li>
            <li class="fragment">Lean 4 (<span style="color: orange">202x</span>)
              <ul>
                <li style="font-size: smaller">Better support for domain-specific syntax and custom automation</li>
                <li style="font-size: smaller">Native code and its formal verification in one language</li>
                <li style="font-size: smaller">In active development at Microsoft Research</li>
              </ul>
            </li>
          </ul>
        </section>
        <!-- TODO: add a provers vs CAS tradeoffs -->
      </section>
      <section>
        <section id="lean-syntax">
          <h3><div class="parent-title"><span>Lean in Practice</span> Definitions, Types, and Terms</div></h3>
          <pre style="font-size: 0.9em; display: inline-grid"><code class="lean" data-trim data-noescape>
            <span class="fragment" data-fragment-index="0">-- name : type := value (or "term")
            def two : ℕ := 2</span>

            <span class="fragment" data-fragment-index="1">def double : ℕ → ℕ :=
            λ a, two * a</span>

            <span class="fragment" data-fragment-index="2">def unlikely : Prop := ∃ x : ℕ, x*x = 2</span>
            <span class="fragment" data-fragment-index="3">lemma unlikely_proof : unlikely := sorry</span>

            <span class="fragment" data-fragment-index="4">lemma double_is_add_self : ∀ a : ℕ, double a = a + a :=</span>
            <span class="fragment" data-fragment-index="5">by { intro a, apply two_mul }</span>
          </code></pre>
          <div class="r-stack">
            <div class="fragment current-only" data-fragment-index="0">
              Lean tries to resemble the math, <code>ℕ = nat</code>.
              <blockquote style="width: 60%">
                mathematicians [have] lower tolerance for unintuitive interfaces than computer scientists.
                <p class="reference">
                  <cite>CICM 2020 slack</cite>
                  <span>Mario Carneiro, PhD in Logic, Lean Maintainer</span>
                </p>
              </blockquote>
            </div>
            <div class="fragment current-only" data-fragment-index="1">
              <code>→</code> declares a function type.<br />
              <code>λ</code> creates a function <i>term</i>.
            </div>
            <div class="fragment current-only" data-fragment-index="2">
              A <code>Prop</code> is a mathematical statement
            </div>
            <div class="fragment current-only" data-fragment-index="3">
              <p><code>Prop</code> instances are themselves <code>Type</code>s.</p>
              <p>Values are their proofs.</p>
            </div>
            <div class="fragment current-only"  data-fragment-index="4">
              <p>Note that <code>a</code> is analogous to a <code>sympy.Symbol</code> here</p>
              <p>Symbols in mathematical statements are the same thing as function arguments!</p>
              <p><code>double_is_add_self 1</code> is a proof that <code>double 1 = 1 + 1</code></p>
            </div>
            <div class="fragment current-only"  data-fragment-index="5">
              <code>intro</code> and  <code>apply</code> are tactics,<br />
              to help us construct proofs interactively
            </div>
          </div>
          <div class="r-stretch"></div>
        </section>
        <section id="lean-typeclasses">
          <h3><div class="parent-title"><span>Lean in Practice</span> <code>class</code> for abstraction</div></h3>
          <pre style="font-size: 0.9em; display: inline-grid"><code class="lean" data-trim data-noescape>
            <span class="fragment" data-fragment-index="0">class add_comm_group (A : Type)</span>
            <span class="fragment" data-fragment-index="1">  extends has_add A, has_zero A, has_neg A : Type :=</span>
            <span class="fragment" data-fragment-index="2">(add_comm     : ∀ a b : A,         a + b = b + a      )
            (add_assoc    : ∀ a b c : A, (a + b) + c = a + (b + c))
            (zero_add     : ∀ a : A,           0 + a = a          )
            (add_one      : ∀ a : A,           a + 0 = a          )
            (add_left_neg : ∀ a : A,          -a + a = 0          )</span>
          </code></pre>
          <div class="r-stack">
            <div class="fragment current-only" data-fragment-index="0">
              <p><code>add_comm_group</code> is the name of our type-class.</p>
              <p>
                <code>A</code> makes this a dependent type,<br />
                <code>add_comm_group A</code> is a collection of proofs that <code>A</code> forms an abelian <code>group</code>.</p>
            </div>
            <div class="fragment current-only" data-fragment-index="1">
              <p><code>extends</code> is inheritance.</p>

              <p>Used here to provide <code>+</code>, <code>0</code> and <code>-</code> for <code>A</code>.</p>
            </div>
            <div class="fragment current-only" data-fragment-index="2">
              The usual abelian group axioms, as fields which hold proofs.
            </div>
            <div class="fragment" data-fragment-index="3">
              <div>
                Type classes form an API
              </div>
                <div class="fragment"  data-fragment-index="4">
                  <p>Theorems <i>consume</i> the API so as to generalize to <i>all</i> abelian groups...</p>
                  <pre><code class="lean" data-trim>
                  lemma neg_add {A : Type u} [add_comm_group A] (a b : G) :
                    -(a + b) = -a + -b := sorry
                  </code></pre>
                </div>
                <div class="fragment" data-fragment-index="5">
                  <p>$\mathbb{H}$ and $\mathbb{R}^{m\times n}$ <i>implement</i> the API to prove they are abelian:</p>
                  <div class="grid" style="grid-template-columns: 1fr 1fr">
                    <pre><code class="lean" data-trim>
                    instance : add_comm_group ℍ :=
                    { add_assoc := sorry, add_comm := sorry,
                      zero_add := sorry,  add_zero := sorry,
                      add_left_neg := sorry }
                    </code></pre>
                    <pre><code class="lean" data-trim>
                    instance : add_comm_group (matrix m n ℝ) :=
                    { add_assoc := sorry, add_comm := sorry,
                      zero_add := sorry,  add_zero := sorry,
                      add_left_neg := sorry }
                    </code></pre>
                  </div>
                </div>
            </div>
          </div>
          <div class="r-stretch"></div>
        </section>
        <section id="lean-determinant">
          <h3><div class="parent-title"><span>Lean in Practice</span>Examples with matrix determinants</div></h3>
          <pre><code class="lean" data-trim>
            import linear_algebra.matrix.nonsingular_inverse
            variables {R m n : Type} [comm_ring R] [fintype m] [fintype n] [decidable_eq m] [decidable_eq n]
            variables (A B : matrix n n R) (P : matrix m n R) (Q : matrix n m R)
            open matrix         -- for `det`
            open_locale matrix  -- for `⬝`
          </code></pre>
          <div class="grid" style="grid-template-columns: 1fr 2fr;">
            <div data-fragment-index="0" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} AB = \operatorname{det} A \operatorname{det} B$$
            </div>
            <div></div>
            <div data-fragment-index="0" class="fragment fade-in-then-semi-out">
              <pre><code class="lean" data-trim>
              example : det (A⬝B) = det A * det B :=
              by simp
              </code></pre>
            </div>
            <div data-fragment-index="0"  class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code>⬝</code> is matrix multiply.</p>
            </div>
            <div data-fragment-index="6" class="fragment semi-fade-out">
              <div class="fragment" data-fragment-index="1">$$\operatorname{det} ABA^{-1} = \operatorname{det} B$$</div>
            </div>
            <div></div>
            <div data-fragment-index="6" class="fragment semi-fade-out">
              <div class="fragment" data-fragment-index="1">
                <pre class="r-stack"><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="1">
                  example :
                    det (A⬝B⬝A⁻¹) = det B :=
                  sorry
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="2">
                  example (hA : is_unit A) :
                    det (A⬝B⬝A⁻¹) = det B :=
                  sorry
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="3">
                  example (hA : is_unit A) :
                    det (A⬝B⬝A⁻¹) = det B :=
                  by <span class="error" title="⊢ A.det * B.det * ring.inverse A.det&#13;    = B.det">simp [hA]</span>
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="4">
                  example (hA : is_unit A) :
                    det (A⬝B⬝A⁻¹) = det B :=
                  by <span class="info" title="Try this: exact det_conj hA B">library_search<!--
                  --></span>
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="5">
                  example (hA : is_unit A) :
                    det (A⬝B⬝A⁻¹) = det B :=
                  by exact det_conj hA B
                </code></pre>
              </div>
            </div>
            <div data-fragment-index="6" class="fragment semi-fade-out" style="text-align: left">
              <p data-fragment-index="1" class="fragment">
                We need a proof that <code>A</code> is invertible, spelt <code>is_unit A</code></p>
              <p data-fragment-index="3" class="fragment"><code>simp</code> takes us to a dead end</p>
              <p data-fragment-index="4" class="fragment"><code>library_search</code> finds that Lean knows this result</p>
            </div>
            <div data-fragment-index="6" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} (I_m + PQ) = \operatorname{det} (I_n + QP)$$
            </div><div></div>
            <div data-fragment-index="6" class="fragment fade-in-then-semi-out">
              <pre><code class="lean" data-trim data-noescape>
              example : det (1 + P⬝Q) = det (1 + Q⬝P) :=
              by <span class="error" title="(1 + P ⬝ Q).det = (1 + Q ⬝ P).det">simp</span>
              </code></pre>
            </div>
            <div data-fragment-index="6" class="fragment fade-in-then-semi-out" style="text-align: left">
              <p>Lean doesn't know this result yet; let's prove it!</p>
            </div>
          </div>
        </section>
        <section id="lean-weinstein-aronszajn">
          <h3><div class="parent-title"><span>Lean in Practice</span>Proving the Weinstein–Aronszajn identity</div></h3>
          <p>How do we prove $\operatorname{det} (1 + PQ) = \operatorname{det} (1 + QP)$ by hand?</p>
          <div style="font-size: 75%">
            \begin{align}
              \operatorname{det}\begin{bmatrix}A & B \\ C & D\end{bmatrix}
              &= \operatorname{det} D \cdot \operatorname{det}(A - BD^{-1}C)
              &\implies \operatorname{det}\begin{bmatrix}I & -P \\ Q & I\end{bmatrix}
              &= \operatorname{det}(I - (-P)Q) = \operatorname{det}(I + PQ)
            \end{align}
          </div>
          <div style="font-size: 75%" class="fragment" data-fragment-index="0">
            \begin{align}
              \operatorname{det}\begin{bmatrix}A & B \\ C & D\end{bmatrix}
              &= \operatorname{det} A \cdot \operatorname{det}(D - CA^{-1}B)
              &\implies \operatorname{det}\begin{bmatrix}I & -P \\ Q & I\end{bmatrix}
              &= \operatorname{det}(I - Q(-P)) = \operatorname{det}(I + QP)
            \end{align}
          </div>
          <div style="display: grid; grid-template: auto / 1fr 1fr; column-gap: var(--r-block-margin); text-align: center">
            <small>(Standard result with schur complement)</small>
            <small>(Set $A = I$, $B=-P$, $C=Q$ and $D = I$)</small>
          </div>
          <div class="r-stretch"></div>
          <div class="fragment" data-fragment-index="1">
            <div class="lean-demo">
              <pre class="r-stack"><code class="lean" data-trim data-noescape>
                /-- The Weinstein–Aronszajn identity -/
                lemma matrix.det_one_plus_comm :
                  det (1 + P⬝Q) = det (1 + Q⬝P) :=
                <span class="fragment" data-fragment-index="3">begin
                  calc det (1 + P⬝Q) = det (from_blocks 1 (-P) Q 1) : _
                                 ... = det (1 + Q⬝P)                : _,
                  <span class="fragment" data-fragment-index="4">{ <span class="fragment" data-fragment-index="5">rewrite det_from_blocks_one₂₂,</span>
                    <span class="fragment" data-fragment-index="6">rewrite matrix.neg_mul,</span>
                    <span class="fragment" data-fragment-index="7">rewrite sub_neg_eq_add,</span> },
                  <span class="fragment" data-fragment-index="9">{ rw [det_from_blocks_one₁₁, matrix.mul_neg,
                        sub_neg_eq_add] },</span></span>
                end</span>
              </code></pre>
              <div class="lean-state">
                <pre class="r-stack fragment" data-fragment-index="1"><code class="lean-goal fragment"
                  data-trim data-fragment-index="1" data-noescape>
                  <span style="opacity: 0.5">R : Type
                  m : Type
                  n : Type
                  _inst_1: comm_ring R
                  _inst_2: fintype m
                  _inst_3: fintype n
                  _inst_4: decidable_eq m
                  _inst_5: decidable_eq n</span>
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="2">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="3">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) =
                      det (from_blocks 1 (-P) Q 1)

                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (from_blocks 1 (-P) Q 1) =
                      det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="4">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) =
                      det (from_blocks 1 (-P) Q 1)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="5">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 - -P⬝Q)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="6">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 - -(P⬝Q))
                </code><code class="lean-goal fragment" data-trim data-fragment-index="7">
                  goals accomplished 🎉
                </code><code class="lean-goal fragment" data-trim data-fragment-index="8">
                  ⊢ det (from_blocks 1 (-P) Q 1) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="9">
                  goals accomplished 🎉
                </code></pre>
              </div>
            </div>
            <div class="r-stack">
              <span class="fragment current-only" data-fragment-index="1">
              State the lemma. Lean provides the goal view, reminding us what we know.</span>
              <span class="fragment current-only" data-fragment-index="2">
                Most of the goal view is noise, so let's cut to the signal</span>
              <span class="fragment current-only" data-fragment-index="3">
                Outline the proof using the <code class="hljs lean">calc</code> tactic. Each <code class="hljs lean">_</code> is a hole, leaving us with two goals (<code class="hljs-goal-sym">⊢</code>).</span>
              <span class="fragment current-only" data-fragment-index="4">
                We can use <code class="hljs lean">{}</code> braces to focus on just the first goal.</span>
              <span class="fragment current-only" data-fragment-index="5">
                Let's expand <code class="hljs lean">det (from_blocks ...)</code> around the bottom right, ...</span>
              <span class="fragment current-only" data-fragment-index="6">
                &hellip; push the negation outside the product, &hellip;</span>
              <span class="fragment current-only" data-fragment-index="7">
                &hellip; and cancel the negations. We're done!</span>
              <span class="fragment current-only" data-fragment-index="8">
                Now we can go back to the other goal. We can solve it the same way, &hellip;</span>
              <span class="fragment current-only" data-fragment-index="9">
                &hellip; but let's write it more concisely.</span>
              <span class="fragment current-only" data-fragment-index="10">
                How did Lean know <code>det_from_blocks_one₁₁</code> and <code>det_from_blocks_one₂₂</code>?.</span>
            </div>
          </div>
        </section>
      </section>
      <section>
        <section id="mathlib" style="height: var(--slide-height)" data-auto-animate>
          <div style="display: grid; align-items: center; height: 100%">
            <h2>Mathlib</h2>
          </div>
        </section>
        <section data-auto-animate>
          <h2>Mathlib</h2>
          <div style="text-align: left">
            <div>
              <p>A mathematical library for Lean, comparable to:</p>
              <ul>
                <li>Coq's <q>mathematical components</q></li>
                <li>Isabelle's <q>HOL-Analysis</q></li>
              </ul>
            </div>
            <div class="fragment">
              <p>Curated by a diverse set of almost 250 <a href="https://leanprover-community.github.io/meet.html#maintainers">maintainers</a> and <a href="https://github.com/math-comp/math-comp/graphs/contributors">contributors</a>:</p>
              <ul>
                <li>role: <span style="opacity: 0.75">Professors, Post-docs, PhD students, Undergrads</span></li>
                <li>origin: <span style="opacity: 0.75">USA, France, The Netherlands, UK, Canada, Australia, &hellip;</span></li>
                <li>expertise: <span style="opacity: 0.75">Mathematics, Computer Science, Physics, AI, &hellip;</span></li>
              </ul>
            </div>
          </div>

          <div class="fragment">
            <img src="images/mathlib-stats.png" style="background: transparent; display: block; margin: auto; margin-top: var(--r-block-margin)" />
            <div class="grid" style="grid-template-columns: auto auto auto; font-size: 1em; ">
              <div><span style="display: block; margin-bottom: -0.5em; opacity: 0.8; font-size: 75%">Definitions</span> 34455</div>
              <div><span style="display: block; margin-bottom: -0.5em; opacity: 0.8; font-size: 75%">Theorems</span> 82184</div>
              <div><span style="display: block; margin-bottom: -0.5em; opacity: 0.8; font-size: 75%">Lines of code</span> 833457</div>
            </div>
            <a href="https://leanprover-community.github.io/mathlib_stats.html" style="font-size: 50%; display: block">https://leanprover-community.github.io/mathlib_stats.html</a>
          </div>
        </section>
        <section id="mathlib-knows-spaghetti" style="height: var(--slide-height)" data-background-iframe="https://eric-wieser.github.io/mathlib-import-graph?highlight=mathlib:linear_algebra.matrix.determinant" data-background-interactive data-preload>
          <div style="display: grid; align-items: center; height: 100%">
            <h3 style="text-shadow: 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white, 0 0 25px white;">What does Mathlib know?</h3>
          </div>
        </section>
        <section id="mathlib-knows-parseval">
          <h3><div class="parent-title"><span>What does Mathlib know?</span>Parseval's theorem</div></h3>
          <div class="grid" style="grid-template: auto / 1fr 1fr">
            <blockquote>
              <p style="font-size: 80%">These amplitudes [$c_n$] can be related to the power content of the signal $g(t)$ over one period</p>
              $$\sum_{n=-\infty}^{\infty}|c_n|^2 dt = \frac{1}{T}\int_{0}^{T}|g(t)|^2 dt$$
              <p style="font-size: 80%; text-align: center">where $g(t) = \sum_{n=-\infty}^{\infty}c_ne^{jn\omega_0t}$</p>
              <p class="reference">
                <cite><a href="http://teaching.eng.cam.ac.uk/content/engineering-tripos-part-ib-2p6-fourier-transforms-signal-and-data-analysis-2020-21">CUED IB Paper 6</a>, Handout 2, Lent 2021</cite>
                <span>S. Godsill</span>
              </p>
            </blockquote>
            <blockquote>
              <p style="font-size: 80%">The sum of the squared norms of the Fourier coefficients equals the $L^2$ norm of the function.</p>
              <pre><code class="lean" data-trim>
                lemma tsum_sq_fourier_series_repr
                  (g : Lp ℂ 2 haar_circle) :
                    ∑' n : ℤ, ∥fourier_series.repr g n∥^2
                      = ∫ t : circle, ∥g t∥^2 ∂haar_circle
              </code></pre>
              <p class="reference">
                <cite><a href="https://leanprover-community.github.io/mathlib_docs/find/tsum_sq_fourier_series_repr">Fourier analysis on the circle</a></cite>
                <span>Mathlib docs</span>
              </p>
            </blockquote>
          </div>
          <div class="fragment">
            <p style="text-align: center">Some translation required!</p>
            <div style="display: grid; grid-template: auto auto auto auto / 1fr min-content 1fr; column-gap: 1em; text-align: left; margin-bottom: var(--r-block-margin)">
              <q style="text-align: right">one period</q> &leftrightarrow; <span><code>t : circle</code></span>
              <q style="text-align: right">$c_n$</q> &leftrightarrow; <span><code>fourier_series.repr g n</code></span>
              <q style="text-align: right">$\frac{1}{T}dt$</q> &leftrightarrow; <span>
                <code>∂haar_circle</code>
                <small style="display: block">(the <q>measure</q> around a circle that sums to 1)</small>
              </span>
              <q style="text-align: right">$g(t) = \sum \cdots$</q> &leftrightarrow; <span>
                <code class="lean">g : Lp ℂ 2 haar_circle</code>
                <small style="display: block">(<code class="lean">g</code> is a function of type <code>circle → ℂ</code>, with finite $L^2$ norm)</small>
              </span>
            </div>
          </div>
        </section>
        <section id="mathlib-knows-cayley-hamilton">
          <h3><div class="parent-title"><span>What does Mathlib know?</span>The Cayley-Hamilton theorem</div></h3>
          <div class="grid" style="grid-template: auto / 1fr 1fr">
            <blockquote>
              <p style="font-size: 80%">
                The characteristic polynomial of $A$ is defined as
                \begin{align}
                p_{A}(\lambda)&=\det(\lambda I_{n}-A) \\
                \textit{[...]}\quad&=\lambda^{n}+c_{n-1}\lambda^{n-1}+\cdots+c_{1}\lambda+c_{0}
                \end{align}
                One can create an analogous polynomial $p_{A}(A)$ [...].
                The Cayley–Hamilton theorem states that $p_A(A) = 0$.
              </p>
              <p class="reference">
                <cite><a href="https://en.wikipedia.org/wiki/Cayley%E2%80%93Hamilton_theorem">Cayley–Hamilton theorem</a></cite>
                <span>Wikipedia</span>
              </p>
            </blockquote>
            <blockquote>
              <p style="font-size: 80%">The characteristic polynomial of a matrix, applied to the matrix itself, is zero.
               This holds over any commutative ring.</p>
              <pre><code class="lean" data-trim>
                lemma matrix.aeval_self_charpoly
                  {R : Type} [comm_ring R]
                  {n : Type} [decidable_eq n] [fintype n]
                  (A : matrix n n R) :
                    polynomial.aeval A A.charpoly = 0
              </code></pre>
              <p class="reference">
                <cite><a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.aeval_self_charpoly">Characteristic polynomials and the Cayley-Hamilton theorem</a></cite>
                <span>Mathlib docs</span>
              </p>
            </blockquote>
          </div>
          <div class="fragment" style="display: grid; grid-template: auto auto auto / 1fr min-content 1fr; column-gap: 1em; text-align: left; margin-bottom: var(--r-block-margin)">
            <q style="text-align: right">$p_A$</q> &leftrightarrow; <span><code>A.charpoly</code></span>
            <q style="text-align: right">$p(A)$</q> &leftrightarrow; <span><code>polynomial.aeval A p</code></span>
          </div>
          <div class="fragment">
            <blockquote>
              <p style="font-size: 80%">Note that by [the] Cayley-Hamilton theorem,
              $e^{A\tau} = I\alpha_0(\tau) + \cdots + A^{n-1}\alpha_{n-1}$</p>
              <p class="reference">
                <cite><a href="http://teaching.eng.cam.ac.uk/content/engineering-tripos-part-iia-3f2-systems-control-2021-22">3F2: Systems and Control</a>, Lecture 4: controllability</cite>
                <span>R. Sepulchre</span>
              </p>
            </blockquote>
            <p>Mathlib does not yet have this corollary, but it is close&hellip;</p>
          </div>
        </section>
        <section id="mathlib-knows-math">
          <div class="grid r-stretch" style="grid-template: min-content auto min-content / 1fr 1fr; height: 100%; margin-top: 0">
            <h3 style="grid-column: 1 / span 2; margin-bottom: 0"><div class="parent-title"><span>What does Mathlib know?</span>Half an Undergraduate Mathematics Degree</div></h3>
            <div class="scroll-container" style="margin-bottom: 0">
              <iframe style="height: 520vh; width: 100%; max-width: none; max-height: none" data-src="https://leanprover-community.github.io/undergrad.html" scrolling="no" data-preload></iframe>
              <div class="fragment" style="position: absolute; top: 170vh" data-fragment-index="0" data-scroll-into-view></div>
              <div class="fragment" style="position: absolute; top: 230vh" data-fragment-index="1" data-scroll-into-view></div>
              <div class="fragment" data-fragment-index="2" data-scroll-into-view></div>
            </div>
            <div class="scroll-container" style="margin-bottom: 0">
              <iframe style="height: 550vh; width: 100%; max-width: none; max-height: none" data-src="https://leanprover-community.github.io/undergrad_todo.html" scrolling="no" data-preload></iframe>
              <div class="fragment" style="position: absolute; top: 125vh" data-fragment-index="0" data-scroll-into-view></div>
              <div class="fragment" style="position: absolute; top: 185vh" data-fragment-index="1" data-scroll-into-view></div>
              <div class="fragment" style="position: absolute; top: 340vh" data-fragment-index="2" data-scroll-into-view></div>
            </div>
            <small><a href="https://leanprover-community.github.io/undergrad.html">
              leanprover-community.github.io/undergrad.html
            </a></small>
            <small><a href="https://leanprover-community.github.io/undergrad_todo.html">
              leanprover-community.github.io/undergrad_todo.html
            </a></small>
          </div>
          <aside class="notes">
            <p>Of particular interest to engineers:</p>
            <ul>
              <li>Linear algebra
                <ul>
                  <li>Vector subspaces</li>
                  <li>Matrices</li>
                  <li>Eigenspaces</li>
                </ul></li>
              <li>Multivariate calculus
                <ul>
                  <li>Partial derivatives</li>
                  <li>Fourier series</li>
                </ul>
              </li>
              <li>Polynomials and power series</li>
              <li>Probability theory</li>
            </ul>
          </aside>
        </section>
        <section id="mathlib-contributions">
          <h3><div class="parent-title"><span>What does Mathlib know?</span>The algebra that I taught it</div></h3>
          <dl style="display: block">
            <dt class="fragment" data-fragment-index="0"><a href="https://leanprover-community.github.io/mathlib_docs/find/dual_number"><code>
              dual_number R</code></a></dt>
            <dd class="fragment" data-fragment-index="0">
              <p>Dual numbers: $R[\varepsilon]$ or $x + \varepsilon y$, where $\varepsilon^2 = 0$.</p>
            </dd>
            <dt class="fragment" data-fragment-index="1"><a href="https://leanprover-community.github.io/mathlib_docs/find/alternating_map"><code>
                alternating_map&nbsp;R&nbsp;V&nbsp;W&nbsp;ι</code></a></dt>
            <dd class="fragment" data-fragment-index="1">
              <p>Alternating maps: $F : V^n \to W$ where $F(\ldots, v_i, \ldots, v_j, \ldots) = 0$ if $v_i = v_j$ for some $i \ne j$.</p>
              <pre style="font-size: 60%"><code class="lean" data-trim>
              /-- det is an `alternating_map` in the rows of the matrix. -/
              def matrix.det_row_alternating : alternating_map R (n → R) R n
              </code></pre>
              <pre style="font-size: 60%"><code class="lean" data-trim>
              /-- If the arguments are linearly dependent then the result is `0`. -/
              theorem alternating_map.map_linear_dependent
                [no_zero_smul_divisors K W] (f : alternating_map K V W ι)
                (v : ι → V) (h : ¬linear_independent K v) : f v = 0
              </code></pre>
            </dd>
            <dt class="fragment" data-fragment-index="2"><a href="https://leanprover-community.github.io/mathlib_docs/find/clifford_algebra"><code>
                clifford_algebra Q</code></a></dt>
            <dd class="fragment" data-fragment-index="2">
              <p>Geometric algebra, $\mathcal{G}(Q)$ (<q>Clifford algebra</q> to mathematicians).</p>
              <pre style="font-size: 60%"><code class="lean" data-trim>
                /-- The clifford algebra over `quaternion_Q` is isomorphic to `ℍ`. -/
                def clifford_algebra_quaternion.equiv :
                  clifford_algebra quaternion_Q ≃ₐ[ℝ] ℍ[ℝ]
              </code></pre>
            </dd>
          </dl>
        </section>
        <section id="mathlib-contributions-2">
          <h3><div class="parent-title"><span>What does Mathlib know?</span>The algebra that I taught it</div></h3>
          <dl style="display: block">
            <dt><a href="https://leanprover-community.github.io/mathlib_docs/find/graded_algebra"><code>
                graded_algebra A</code></a></dt>
            <dd>
              <p>Graded algebras: $A = \bigoplus_i A_i$ where $A_iA_j \subseteq A_{i+j}$</p>
              <pre style="font-size: 60%"><code class="lean" data-trim>
                structure set_like.graded_monoid (A : ι → S) :
                (one_mem : 1 ∈ A 0)
                (mul_mem : ∀ {i j : ι} {gi gj : R}, gi ∈ A i → gj ∈ A j → gi * gj ∈ A (i + j))
              </code></pre>
              <pre style="font-size: 60%"><code class="lean" data-trim>
              /-- An internally-graded `R`-algebra `A` is one that can be decomposed into a
              collection of `submodule R A`s indexed by `ι` such that the canonical map
              `A → ⨁ i, 𝒜 i` is bijective. -/
              class graded_algebra extends set_like.graded_monoid 𝒜 :=
              (decompose' : A → ⨁ i, 𝒜 i)
              (left_inv : function.left_inverse decompose' (direct_sum.submodule_coe 𝒜))
              (right_inv : function.right_inverse decompose' (direct_sum.submodule_coe 𝒜))
              </code></pre>
              <pre style="font-size: 60%"><code class="lean" data-trim>
              /-- The clifford algebra is graded by the even and odd parts. -/
              def clifford_algebra.graded_algebra :
                graded_algebra (clifford_algebra.even_odd Q)
              </code></pre>
            </dd>
            <dt>Miscellaneous proofs</dt>
            <dd>The matrix lemma we proved in this presentation, and hundreds of smaller results in linear algebra, ring theory, and more.</dd>
          </dl>
        </section>
        <section id="mathlib-contributions-you">
          <h3><div class="parent-title"><span>What does Mathlib know?</span>The algebra this audience wants to teach it?</div></h3>
          <!-- TODO -->
        </section>
      </section>
      <section>
        <h3>References</h3>
        <div style="text-align: left">
          <p class="reference">
            <cite><a href="https://doi.org/10.7717/peerj-cs.103">SymPy: symbolic computing in Python</a> (2017)</cite>
            <span>Meurer A, Smith CP, Paprocki M, Čertík O, Kirpichev SB, Rocklin M, Kumar A, Ivanov S, Moore JK, Singh S, Rathnayake T, Vig S, Granger BE, Muller RP, Bonazzi F, Gupta H, Vats S, Johansson F, Pedregosa F, Curry MJ, Terrel AR, Roučka Š, Saboo A, Fernando I, Kulal S, Cimrman R, Scopatz A</span>
          </p>
          <p class="reference">
            <cite><a href="https://www.researchgate.net/publication/2657821_Quaternionic_Analysis">Quaternionic analysis</a> (1977)</cite>
            <span>A. Sudbery</span>
          </p>
          <p class="reference">
            <cite><a href="https://link.springer.com/chapter/10.1007/978-3-319-21401-6_26">The Lean Theorem Prover (System Description)</a> (2015)</cite>
            <span>Leonardo de Moura, Soonho Kong, Jeremy Avigad, Floris van Doorn, Jakob von Raumer</span>
          </p>
          <p class="reference">
            <cite><a href="https://dl.acm.org/doi/10.1145/3372885.3373824">The lean mathematical library</a> (2020)</cite>
            <span>The mathlib Community</span>
          </p>
        </div>
        <div class="r-stretch"></div>
        <p>The lean community website: <a href="https://leanprover-community.github.io">leanprover-community.github.io</a></p>
        <p>These slides: <a href="https://eric-wieser.github.io/divf-2022">eric-wieser.github.io/divf-2021</a></p>
      </section>
    </div>
  </div>
  <script src="reveal.js/dist/reveal.js"></script>
  <script src="reveal.js/plugin/highlight/highlight.js"></script>
  <script src="reveal.js/plugin/math/math.js"></script>
  <script src="reveal.js/plugin/notes/notes.js"></script>
  <script src="js/lean.min.js"></script>
  <script src="js/lean-goal.js"></script>
  <script src="js/vendor/Chart.min.js"></script>
  <script src="js/charts/cas.js"></script>
  <script src="js/charts/provers.js"></script>
  <script>
    Chart.defaults.global.defaultFontColor='black';
    Chart.defaults.global.defaultColor='black';
    Chart.defaults.global.defaultFontSize = 16;

    Reveal.initialize({
      mathjax3: {
        mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js',
        loader: {load: ['[tex]/mathtools', '[tex]/centernot']},
        tex: {
          packages: {'[+]': ['mathtools', 'centernot']},
        },
        chtml: {
          // This seems to break rendering on slides that weren't onscreen at render time
          // mtextInheritFont: true,
          mtextFont: 'Source Sans Pro',
        },
        options: {
          skipHtmlTags: {'[-]': ['code', 'pre']},
        },
      },
      plugins: [
        RevealHighlight,
        RevealMath.MathJax3,
        RevealNotes,
      ],
      history: true,
      center: false,
      // defaultTiming: 40,
      slideNumber: 'c/t',
      width: 1280*0.96,
      height: 1024*0.96,
      margin: 0.04,
      navigationMode: 'linear',
      // showNotes: 'separate-page'
    });

    Reveal.on('fragmenthidden', event => {
      var activeFragments = Reveal.getCurrentSlide().querySelectorAll('.current-fragment');
      var seen = new Set();
      Array.from(activeFragments).forEach(f => {
        if (f && f.hasAttribute('data-scroll-into-view')) {
          f.parentElement.scrollTop = f.offsetTop;
          seen.add(f.parentElement);
        }
      });
      event.fragments.forEach(f => {
        if (f.hasAttribute('data-scroll-into-view') && !seen.has(f.parentElement)) {
          f.parentElement.scrollTop = 0
        }
      });
    } );
    Reveal.on('fragmentshown', event => {
      event.fragments.forEach(f => {
        if (f.hasAttribute('data-scroll-into-view')) {
          f.parentElement.scrollTop = f.offsetTop;
        }
      });
    } );
  </script>
  <script src="js/inline_svg.js"></script>
</body>

</html>