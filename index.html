<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="reveal.js/dist/reset.css" />
  <link rel="stylesheet" href="reveal.js/dist/reveal.css" />
  <link rel="stylesheet" href="reveal.js/dist/theme/white.css" />
  <link rel="stylesheet" href="css/hljs.css" />
  <link rel="stylesheet" href="css/common.css" />
  <link rel="shortcut icon" type="image/png" href="https://ericwieser.me/images/favicon.png"/>
  <meta name="author" content="Eric Wieser" />
  <meta name="description" content="
    Working with noncommutative algebras in computer algebra systems (CAS) can be challenging.
    Taking a popular CAS as an example; Python's sympy can run into various difficulties when working with the matrix and quaternion algebras, and building more unusual algebras only makes matters worse.
    While on the surface solving a similar class of problems to CAS, theorem provers offer a very strong correctness guarantee.
    As it turns out, the design decisions that ensure this guarantee are the same as those which provide the extensionality needed for adding new algebraic constructions.
    With this background, this talk acts as an introduction to the Lean theorem prover by example, and demonstrates some of the trade-offs to be made by choosing to use a theorem prover over a CAS.
    With the help of Lean's comprehensive library of formalized mathematics, Mathlib, I'll show how to manipulate and simplify some matrix expressions.
    Lean and Mathlib are a collaborative effort; this talk concludes with a summary of the more interesting parts I myself have contributed." />
  <meta name="keywords" content="sympy, lean, non-commutative algebra, mathlib" />
  <title>Non-commutative algebras, computer algebra systems, and theorem provers</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1>Non-commutative algebras, computer algebra systems, and theorem provers</h1>

        <p>Eric Wieser<br/> Cambridge University Engineering Department</p>
        <small>slides: <a href="https://eric-wieser.github.io/divf-2022">
        eric-wieser.github.io/divf-2022</a></small>
        <small style="display: block; text-align: center; opacity: 0.5">2022-03-25</small>
        <aside class="notes">
          <p>Hi, I'm Eric Wieser, a PhD student at Cambridge University</p>
        </aside>
      </section>
      <section>
        <section>
          <h2>Examples of non-commutative algebras</h2>
          <p>Most algebra we manipulate has commutative <emph>multiplication</emph>, $ab = ba$</p>
          <ul>
            <li>the real numbers $\mathbb{R}$</li>
            <li>the complex numbers $\mathbb{C}$ ($x + y\mathrm{i}$)</li>
          </ul>
          <p>Geometry is inherently non-commutative:</p>
          <ul>
            <li>rotations in 3D don't commute</li>
            <li>the oriented plane spanning $u$ and $v$ faces the opposite way to the one spanning $v$ and $u$</li>
          </ul>
          <p>Any algebraic system representing geometry of this kind will have non-commutative multiplication!</p>

          <ul>
            <li>Matrices, $\mathbb{R}^{m \times n}$
              <ul>
                <li>Elements of the form
                  $\left[\begin{smallmatrix}
                    a_{11} & \cdots & a_{1n} \\
                    \vdots & \ddots & \vdots \\
                    a_{m1} & \cdots & a_{mn} \\
                  \end{smallmatrix}\right]$</li>
              </ul></li>
            <li>Quaternions, $\mathbb{Q}$:
              <ul>
                <li>Elements of the form $r + x\mathrm{i} + y\mathrm{j} + z\mathrm{k}$</li>
                <li>Rotation around the axis $u$ by $\theta$ is $e^{\frac{\theta}{2}{(u_x\mathrm{i} + u_y\mathrm{j} + u_z\mathrm{k})}} = \cos \frac{\theta}{2} + (u_x\mathrm{i} + u_y\mathrm{j} + u_z\mathrm{k}) \sin \frac{\theta}{2}$</li>
              </ul></li>
            <li>The exterior algebra, $\bigwedge(V)$
              <ul><li>Element of the form $a + \sum_{i}a_i\mathrm{e}_i + \sum_{i,j,i&lt;j}a_{ij}(\mathrm{e}_i \wedge \mathrm{e}_j) + \sum_{i,j,k,i&lt;j&lt;k}a_{ijh}(\mathrm{e}_i \wedge \mathrm{e}_j \wedge \mathrm{e}_k) + \cdots$</li></ul>
            <li>The geometric algebra, $\mathcal{G}(\mathbb{R}^n)$</li>
          </ul>
        </section>
      </section>
      <section>
        <section>
          <h2>Computer algebra systems</h2>
          <blockquote>
            A computer algebra system (CAS) or symbolic algebra system (SAS) is any mathematical software with the ability to manipulate mathematical expressions in a way similar to the traditional manual computations of mathematicians and scientists.
            <p class="reference">
              <cite><a href="https://en.wikipedia.org/wiki/Computer_algebra_system">Computer algebra system</a></cite>
              <span>Wikipedia</span>
            </p>
          </blockquote>
          <div style="display: grid; grid-template: auto / auto auto; column-gap: var(--r-block-margin)">
            <div>
              <p>Useful for</p>
              <ul>
                <li>Roughly checking your work</li>
                <li>Answering what-if questions experimentally</li>
                <li>Solving large but tedious equations quickly</li>
                <li>&hellip;</li>
              </ul>
            </div>
            <div>
              <p>Typical features</p>
              <ul>
                <li>Algebraic simplification</li>
                <li>Root finding</li>
                <li>Integration and differentiation</li>
                <li>Arbitrary precision calculations</li>
                <li>&hellip;</li>
              </ul>
            </div>
          </div>
            <div>
              <p>Notable implementations</p>
              <div style="height:50px; position:relative; width: 90%; margin: auto; margin-bottom: 20px">
                <canvas id="cas-timeline" />
              </div>
              <ul style="columns: 3; list-style-type: none">
                <li>Axiom (1965, BSD License)</li>
                <li style="text-align: right">Maxima (1982, GPL License)</li>
                <li>Maple (1982, Proprietary)</li>
                <li style="text-align: right">Magma (1993, Proprietary) </li>
                <li>Mathematica (1998, Proprietary)</li>
                <li style="text-align: right">SageMath (2004, GPL)</li>
              </ul>
            </div>
        </section>
        <section>
          <h2>Sympy</h2>
          <blockquote>
            SymPy is a Python library for symbolic mathematics. It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python.
            <p class="reference">
              <cite><a href="https://www.sympy.org/en/index.html">SymPy's website</a></cite>
              <!-- <span>Sympy.org</span> -->
            </p>
          </blockquote>
          <p class="fragment" style="text-align: center">Why wasn't this on the previous slide?</p>
          <blockquote class="fragment">
            Sage[Math] tries to gather together all the major open source mathematics software, and glue it together into a useful system. In fact, Sage[Math] includes SymPy as one of its systems.
            <p class="reference">
              <cite><a href="https://stackoverflow.com/q/17847902/102441">What is the difference between SymPy and Sage[Math]?</a></cite>
              <span>Aaron Meurer (Lead SymPy developer)</span>
            </p>
          </blockquote>
        </section>
        <section>
          <h2>Some sympy examples</h2>
          TODO
        </section>
        <section>
          <h3>Expression trees</h3>
          <pre><code class="pycon" data-trim>
          >>> from sympy import *; from this_presentation import show_repr
          </code></pre>
          <div style="display: grid; grid-template: auto auto / 1fr 1fr; column-gap: var(--r-block-margin)">
            <div class="fragment">
              <h4>Real numbers</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; x, y = symbols('x y', real=True)
              &gt;&gt;&gt; expr = (x + y)*(x - y); expr
              $(x - y)(x + y)$
              <span class="fragment">&gt;&gt;&gt; show_repr(expr)
              Mul(Add($x$, Mul(Integer(-1), $y$)),
                  Add($x$, $y$))</span>
              </code></pre>
            </div>
            <div class="fragment">
              <h4>Complex numbers</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; x, y = symbols('x y', complex=True)
              &gt;&gt;&gt; expr = (x + y)*(x - y); expr
              $(x - y)(x + y)$
              <span class="fragment">&gt;&gt;&gt; show_repr(expr)
              Mul(Add($x$, Mul(Integer(-1), $y$)),
                  Add($x$, $y$))</span>
              </code></pre>
            </div>
            <div class="fragment">
              <h4>Matrices</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; m, n = symbols('m n')
              &gt;&gt;&gt; X = MatrixSymbol('X', m, n)
              &gt;&gt;&gt; Y = MatrixSymbol('Y', m, n)
              &gt;&gt;&gt; expr = (X + Y)*(X - Y).T; expr
              $(X + Y)(X^T - Y^T)$
              <span class="fragment">&gt;&gt;&gt; show_repr(expr)
              MatMul(MatAdd($X$, $Y$),
                     MatAdd(Transpose($X$),
                            MatMul(Integer(-1), Transpose($Y$))))</span>
              </code></pre>
            </div>
          </div>
        </section>
        <section>
          <h3>Expression trees</h3>
          <div>
            <p>Quaternions</p>
            <pre><code class="pycon" data-trim data-noescape>
            &gt;&gt;&gt; (x, xi, xj, xk), (y, yi, yj, yk) = symbols('x x_i x_j x_k'), symbols('y y_i y_j y_k')
            &gt;&gt;&gt; xq, yq = Quaternion(x, xi, xj, xk), Quaternion(y, yi, yj, yk)
            &gt;&gt;&gt; expr = xq * yq; expr
            $\left(x y - x_{i} y_{i} - x_{j} y_{j} - x_{k} y_{k}\right) + \left(x y_{i} + x_{i} y + x_{j} y_{k} - x_{k} y_{j}\right) i + \left(x y_{j} - x_{i} y_{k} + x_{j} y + x_{k} y_{i}\right) j + \left(x y_{k} + x_{i} y_{j} - x_{j} y_{i} + x_{k} y\right)$
            <span class="fragment">&gt;&gt;&gt; show_repr(expr)
            Quaternion(Add(Mul($x$, $y$), Mul(Integer(-1), $x_i$, $y_i$), Mul(Integer(-1), $x_j$, $y_j$), Mul(Integer(-1), $x_k$, $y_k$)),
                       Add(Mul($x$, $y_i$), Mul($x_i$, $y$), Mul($x_j$, $y_k$), Mul(Integer(-1), $x_k$, $y_j$)),
                       Add(Mul($x$, $y_j$), Mul(Integer(-1), $x_i$, $y_k$), Mul($x_j$, $y$), Mul($x_k$, $y_i$)),
                       Add(Mul($x$, $y_k$), Mul($x_i$, $y_j$), Mul(Integer(-1), $x_j$, $y_i$), Mul($x_k$, $y$)))</span>
            </code></pre>
          </div>
          <ul class="fragment">
            <li>Real: <code>Add</code>, <code>Mul</code>, ...</li>
            <li>Complex: <code>Add</code>, <code>Mul</code>, ...</li>
            <li>Matrix: <code>MatrixAdd</code>, <code>MatrixMul</code>, ...</li>
            <li>Quaternion: ???</li>
          </ul>
        </section>
        <section>
          <h3>Example: Checking matrix determinants</h3>
          <div style="display: grid; grid-template: auto / auto auto auto; column-gap: var(--r-block-margin)">
            <div>
              <pre><code class="pycon" data-trim>
              >>> m, n = symbols('m, n')
              </code></pre>
            </div>
            <div>
              <pre><code class="pycon" data-trim>
              >>> A = MatrixSymbol('A', n, n)
              >>> B = MatrixSymbol('B', n, n)
              </code></pre>
            </div>
            <div>
              <pre><code class="pycon" data-trim>
              >>> P = MatrixSymbol('P', m, n)
              >>> Q = MatrixSymbol('Q', n, m)
              </code></pre>
            </div>
          </div>
          <div style="display: grid; grid: auto auto auto / 1fr 2fr; align-items: end; column-gap: var(--r-block-margin)">
            <div data-fragment-index="0" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} AB = \operatorname{det} A \operatorname{det} B$$
              <pre><code class="pycon" data-trim>
              >>> Eq(det(A*B), det(A)*det(B))
              $\text{True}$
              </code></pre>
            </div>
            <div data-fragment-index="0"  class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code class="python">Eq</code> can be used to write down a symbolic equality.</p>
              <p><code>sympy</code> is automatically performing this simplification for us, via <code class="python">MatMul._eval_determinant</code>.</p>
            </div>
            <div data-fragment-index="1"  class="fragment fade-in-then-semi-out">
              $$\operatorname{det} ABA^{-1} = \operatorname{det} B$$
              <pre><code class="pycon" data-trim>
              >>> Eq(det(A*B*A.inv()), det(B))
              $\left|{A^{-1}}\right| \left|{A}\right| \left|{B}\right| = \left|{B}\right|$
              >>> Eq(det(A*B*A.inv()), det(B)).simplify()
              $\text{True}$
              </code></pre>
            </div>
            <div data-fragment-index="1" class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code class="python">MatMul._eval_determinant</code> gets us partway there, but doesn't finish the job.</p>
              <p><code class="python">simplify()</code> can clean up.</p>
            </div>
            <div data-fragment-index="2" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} (I_m + PQ) = \operatorname{det} (I_n + QP)$$
              <pre><code class="pycon" data-trim>
              >>> I = Identity
              >>> Eq(det(I(m) + P*Q), det(I(n) + Q*P))
              $\left|{\mathbb{I} + PQ}\right| = \left|{\mathbb{I} + QP}\right|$
              >>> Eq(det(I(m) + P*Q), det(I(n) + Q*P)).simplify()
              NonSquareMatrixError: Det of a non-square matrix
              </code></pre>
            </div>
            <div data-fragment-index="2" class="fragment fade-in-then-semi-out" style="text-align: left">
              <p>(sometimes called the <q>Weinstein–Aronszajn</q> identity)</p>
              <p>There is no <code class="python">MatAdd._eval_determinant</code> to help here, it wouldn't generalize well anyway.</p>
              <p>Simplification is ad-hoc, and sometimes crashes!</p>
            </div>
          </div>
        </section>
      </section>
      <section>
        <h2>Theorem proving languages - History</h2>
        <div style="height:50px; position:relative; width: 90%; margin: auto; margin-bottom: 20px">
          <canvas id="lean-timeline" />
        </div>
        <ul>
          <li class="fragment">Relatively new (compared to other actively used tools)
            <ul>
              <li style="font-size: smaller">Mizar (<span style="color: #42affa">1973</span>), Isabelle (<span style="color: #42affa">1986</span>), HOL Family (<span style="color: #42affa">1988</span>)</li>
              <li style="font-size: smaller">Coq (<span style="color: #42affa">1989</span>), Metamath (<span style="color: #42affa">1993</span>), Agda (<span style="color: #42affa">2007</span>)</li>
              <li style="font-size: smaller">Lean 1 (<span style="color: green">2013</span>) & Lean 2 (<span style="color: green">2015</span>)</li>
            </ul>
            <blockquote>
              Lean had the advantage of being born later and learning from past mistakes.
              <p class="reference">
                <cite>CICM 2020 slack</cite>
                <span>Mario Carneiro, Lean Maintainer</span>
              </p>
            </blockquote>
          </li>
          <li class="fragment">Lean 3 (<span style="color: green">2016</span>)
            <ul>
              <li style="font-size: smaller">Actively maintained by the community (v3.24.0 to v3.35.1 in 2021)</li>
              <li style="font-size: smaller">Can be used <a href="https://leanprover.github.io/live/latest/">in-browser</a> or in supported IDEs: <a href="https://github.com/leanprover/vscode-lean">VS Code</a> and <a href="https://github.com/leanprover/lean-mode">Emacs</a></li>
            </ul>
          </li>
          <li class="fragment">Lean 4 (<span style="color: orange">202x</span>)
            <ul>
              <li style="font-size: smaller">Better support for domain-specific syntax and custom automation</li>
              <li style="font-size: smaller">Native code and its formal verification in one language</li>
              <li style="font-size: smaller">In active development at Microsoft Research</li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
        <section>
          <h3><div class="parent-title"><span>Lean in Practice</span> Definitions, Types, and Terms</div></h3>
          <pre style="font-size: 1.2em; display: inline-grid"><code class="lean" data-trim data-noescape>
            <span class="fragment" data-fragment-index="0">-- name : type := value (or "term")
            def two : ℕ := 2</span>

            <span class="fragment" data-fragment-index="1">def double : ℕ → ℕ :=
            λ a, two * a</span>

            <span class="fragment" data-fragment-index="2">def unlikely : Prop := ∃ (x : ℕ), x*x = 2</span>
            <span class="fragment" data-fragment-index="3">lemma unlikely_proof : unlikely := sorry</span>

            <span class="fragment" data-fragment-index="4">lemma double_is_add_self : ∀ a, double a = a + a :=</span>
            <span class="fragment" data-fragment-index="5">by { intro a, apply two_mul }</span>
          </code></pre>
          <div class="r-stack">
            <div class="fragment current-only" data-fragment-index="0">
              Lean tries to resemble the math, <code>ℕ = nat</code>.
              <blockquote style="width: 60%">
                mathematicians [have] lower tolerance for unintuitive interfaces than computer scientists.
                <p class="reference">
                  <cite>CICM 2020 slack</cite>
                  <span>Mario Carneiro, PhD in Logic, Lean Maintainer</span>
                </p>
              </blockquote>
            </div>
            <div class="fragment current-only" data-fragment-index="1">
              <code>→</code> declares a function type.<br />
              <code>λ</code> creates a function <i>term</i>.
            </div>
            <div class="fragment current-only" data-fragment-index="2">
              A <code>Prop</code> is a mathematical statement
            </div>
            <div class="fragment current-only" data-fragment-index="3">
              <p><code>Prop</code> instances are themselves <code>Type</code>s.</p>
              <p>Values are their proofs.</p>
            </div>
            <div class="fragment current-only"  data-fragment-index="4">
              <code>double_is_add_self 1</code> <br /> is a proof that <code>double 1 = 1 + 1</code>
            </div>
            <div class="fragment current-only"  data-fragment-index="5">
              <code>intro</code> and  <code>apply</code> are tactics,<br />
              to help us construct proofs interactively
            </div>
          </div>
          <div class="r-stretch"></div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Lean in Practice</span> <code>class</code> for abstraction</div></h3>
          <pre style="font-size: 1.2em; display: inline-grid"><code class="lean" data-trim data-noescape>
            <span class="fragment" data-fragment-index="0">class add_comm_group (A : Type)
              extends has_add A, has_zero A, has_neg A : Type :=</span>
            <span class="fragment" data-fragment-index="2">(add_comm     : ∀ a b : A,         a + b = b + a      )
            (add_assoc    : ∀ a b c : A, (a + b) + c = a + (b + c))
            (zero_add     : ∀ a : A,           0 + a = a          )
            (add_one      : ∀ a : A,           a + 0 = a          )
            (add_left_neg : ∀ a : A,          -a + a = 0          )</span>
          </code></pre>
          <div class="r-stack">
            <div class="fragment current-only" data-fragment-index="0">
              <p><code>group</code> is the name of our type-class.</p>
              <p>
                <code>A</code> makes this a dependent type,<br />
                <code>add_comm_group A</code> is a collection of proofs that <code>A</code> forms an abelian <code>group</code>.</p>
            </div>
            <div class="fragment current-only" data-fragment-index="1">
              <p><code>extends</code> is inheritance.</p>

              <p>Used here to provide <code>*</code>, <code>1</code> and <code>⁻¹</code> for <code>A</code>.</p>
            </div>
            <div class="fragment current-only" data-fragment-index="2">
              The usual abelian group axioms, as fields which hold proofs.
            </div>
            <div class="fragment" data-fragment-index="3">
              <div>
                Type classes form an API
              </div>
              <div class="fragment"  data-fragment-index="4">
                <hr />
                <p>Showing $\mathbb{R}$ is an abelian group means <i>implementing</i> the API:</p>
                <pre><code class="lean" data-trim>
                instance : add_comm_group ℝ :=
                { add_assoc := sorry,  add_comm := sorry, zero_add := sorry, add_zero := sorry, add_left_neg := sorry }
                </code></pre>
              </div>
              <div class="fragment"  data-fragment-index="5">
                <hr />
                <p>Proofs working over an abelian group <i>use</i> the API,<br />
                and generalize to <i>all</i> groups...</p>
              </div>
            </div>
          </div>
          <div class="r-stretch"></div>
        </section>
      </section>
      <section id="mathlib-graph" data-background-iframe="https://eric-wieser.github.io/mathlib-import-graph?highlight=mathlib:linear_algebra.clifford_algebra.basic" data-background-interactive>
      </section>
      <section>
        <section id="matrix-determinant-lean">
          <h3>Example: Checking matrix determinants</h3>
          <pre><code class="lean" data-trim>
            import linear_algebra.matrix.nonsingular_inverse
            variables {R m n : Type*} [comm_ring R] [fintype m] [fintype n] [decidable_eq m] [decidable_eq n]
            variables (A B : matrix n n R) (P : matrix m n R) (Q : matrix n m R)
            open matrix         -- for `det`
            open_locale matrix  -- for `⬝`
          </code></pre>
          <div style="display: grid; grid: auto auto auto / 1fr 2fr; align-items: end; column-gap: var(--r-block-margin)">
            <div data-fragment-index="0" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} AB = \operatorname{det} A \operatorname{det} B$$
              <pre><code class="lean" data-trim>
              example : det (A⬝B) = det A * det B :=
              by simp
              </code></pre>
            </div>
            <div data-fragment-index="0"  class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code>⬝</code> is matrix multiply.</p>
            </div>
            <div data-fragment-index="6" class="fragment semi-fade-out">
              <div class="fragment" data-fragment-index="1">
                $$\operatorname{det} ABA^{-1} = \operatorname{det} B$$
                <pre class="r-stack"><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="1" class="fragment">
                  example : det (A⬝B⬝A⁻¹) = det B :=
                  sorry
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="2">
                  example (hA : is_unit A) : det (A⬝B⬝A⁻¹) = det B :=
                  sorry
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="3">
                  example (hA : is_unit A) : det (A⬝B⬝A⁻¹) = det B :=
                  by <span class="error" title="⊢ A.det * B.det * ring.inverse A.det = B.det">simp [hA]<!--
                  --></span>
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="4">
                  example (hA : is_unit A) : det (A⬝B⬝A⁻¹) = det B :=
                  by <span class="info" title="Try this: exact det_conj hA B">library_search<!--
                  --></span>
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="5">
                  example (hA : is_unit A) : det (A⬝B⬝A⁻¹) = det B :=
                  by exact det_conj hA B
                </code></pre>
              </div>
            </div>
            <div data-fragment-index="6" class="fragment semi-fade-out" style="text-align: left">
              <p data-fragment-index="1" class="fragment">
                We need a proof that <code>A</code> is invertible, spelt <code>is_unit A</code></p>
              <p data-fragment-index="3" class="fragment"><code>simp</code> takes us to a dead end</p>
              <p data-fragment-index="5" class="fragment"><code>library_search</code> finds that Lean knows this result</p>
            </div>
            <div data-fragment-index="6" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} (I_m + PQ) = \operatorname{det} (I_n + QP)$$
              <pre><code class="lean" data-trim data-noescape>
              example : det (1 + P⬝Q) = det (1 + Q⬝P) :=
              by <span class="error" title="(1 + P ⬝ Q).det = (1 + Q ⬝ P).det">simp</span>
              </code></pre>
            </div>
            <div data-fragment-index="6" class="fragment fade-in-then-semi-out" style="text-align: left">
              <p>Lean doesn't know this result yet; let's prove it!</p>
            </div>
          </div>
        </section>
        <section>
          <h3>Proving the Weinstein–Aronszajn identity in lean</h3>
          <p>How do we prove $\operatorname{det} (1 + PQ) = \operatorname{det} (1 + QP)$ by hand?</p>
          <div style="font-size: 90%">
            \begin{align}
              \operatorname{det}\begin{bmatrix}A & B \\ C & D\end{bmatrix}
              &= \operatorname{det} D \cdot \operatorname{det}(A - BD^{-1}C)
              &\implies \operatorname{det}\begin{bmatrix}I & -P \\ Q & I\end{bmatrix}
              &= \operatorname{det}(I - (-P)Q) = \operatorname{det}(I + PQ)
            \end{align}
          </div>
          <div style="font-size: 90%" class="fragment" data-fragment-index="0">
            \begin{align}
              \operatorname{det}\begin{bmatrix}A & B \\ C & D\end{bmatrix}
              &= \operatorname{det} A \cdot \operatorname{det}(D - CA^{-1}B)
              &\implies \operatorname{det}\begin{bmatrix}I & -P \\ Q & I\end{bmatrix}
              &= \operatorname{det}(I - Q(-P)) = \operatorname{det}(I + QP)
            \end{align}
          </div>
          <div style="display: grid; grid-template: auto / 1fr 1fr; column-gap: var(--r-block-margin); text-align: center">
            <div>(Standard result with schur complement)</div>
            <div>(Set $A = I$, $B=-P$, $C=Q$ and $D = I$)</div>
          </div>
          <div class="r-stretch"></div>
          <div class="fragment" data-fragment-index="1">
            <div class="lean-demo">
              <pre class="r-stack"><code class="lean" data-trim data-noescape>
                /-- The Weinstein–Aronszajn identity -/
                lemma matrix.det_one_plus_comm :
                  det (1 + P⬝Q) = det (1 + Q⬝P) :=
                <span class="fragment" data-fragment-index="3">begin
                  calc det (1 + P⬝Q) = det (from_blocks 1 (-P) Q 1) : _
                                 ... = det (1 + Q⬝P)                : _,
                  <span class="fragment" data-fragment-index="4">{ <span class="fragment" data-fragment-index="5">rewrite det_from_blocks_one₂₂,</span>
                    <span class="fragment" data-fragment-index="6">rewrite matrix.neg_mul,</span>
                    <span class="fragment" data-fragment-index="7">rewrite sub_neg_eq_add,</span> },
                  <span class="fragment" data-fragment-index="9">{ rw [det_from_blocks_one₁₁, matrix.mul_neg,
                        sub_neg_eq_add] },</span></span>
                end</span>
              </code></pre>
              <div class="lean-state">
                <pre class="r-stack fragment" data-fragment-index="1"><code class="lean-goal fragment"
                  data-trim data-fragment-index="1" data-noescape>
                  <span style="opacity: 0.5">R : Type u_1
                  m : Type u_2
                  n : Type u_3
                  _inst_1: comm_ring R
                  _inst_2: fintype m
                  _inst_3: fintype n
                  _inst_4: decidable_eq m
                  _inst_5: decidable_eq n</span>
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="2">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="3">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (from_blocks 1 (-P) Q 1)

                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (from_blocks 1 (-P) Q 1) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="4">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (from_blocks 1 (-P) Q 1)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="5">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 - -P⬝Q)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="6">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 - -(P⬝Q))
                </code><code class="lean-goal fragment" data-trim data-fragment-index="7">
                  goals accomplished 🎉
                </code><code class="lean-goal fragment" data-trim data-fragment-index="8">
                  ⊢ det (from_blocks 1 (-P) Q 1) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="9">
                  goals accomplished 🎉
                </code></pre>
              </div>
            </div>
            <div class="r-stack">
              <span class="fragment current-only" data-fragment-index="1">
              State the lemma. Lean provides the goal view, reminding us what we know.</span>
              <span class="fragment current-only" data-fragment-index="2">
                Most of the goal view is noise, so let's cut to the signal</span>
              <span class="fragment current-only" data-fragment-index="3">
                Outline the proof using the <code class="hljs lean">calc</code> tactic. Each <code class="hljs lean">_</code> is a hole, leaving us with two goals (<code class="hljs-goal-sym">⊢</code>).</span>
              <span class="fragment current-only" data-fragment-index="4">
                We can use <code class="hljs lean">{}</code> braces to focus on just the first goal.</span>
              <span class="fragment current-only" data-fragment-index="5">
                Let's expand <code class="hljs lean">det (from_blocks ...)</code> around the bottom right, ...</span>
              <span class="fragment current-only" data-fragment-index="6">
                &hellip; push the negation outside the product, &hellip;</span>
              <span class="fragment current-only" data-fragment-index="7">
                &hellip; and cancel the negations. We're done!</span>
              <span class="fragment current-only" data-fragment-index="8">
                Now we can go back to the other goal. We can solve it the same way, &hellip;</span>
              <span class="fragment current-only" data-fragment-index="9">
                &hellip; but let's write it more concisely.</span>
            </div>
          </div>
        </section>
      </section>
      <section id="mathlib-contributions">
        <h2>Contributions to mathlib</h2>
        <ul>
          <li>Exterior algebra: $\bigwedge(V)$.
            <a href="https://leanprover-community.github.io/mathlib_docs/find/exterior_algebra"><code>
              exterior_algebra R V</code></a></li>
          <li>Alternating maps: $F : V^n \to W$ where $v_i = v_j \implies F(\ldots, v_i, \ldots, v_j, \ldots) = 0$.
            <a href="https://leanprover-community.github.io/mathlib_docs/find/alternating_map"><code>
              alternating_map R V</code></a></li>
          <li>Clifford algebra: $\mathcal{C}\ell(Q)$
            <a href="https://leanprover-community.github.io/mathlib_docs/find/clifford_algebra"><code>
              clifford_algebra Q</code></a></li>
          <li>Dual numbers: $R[\varepsilon]$ or $x + \varepsilon y$, where $\varepsilon^2 = 0$
            <a href="https://leanprover-community.github.io/mathlib_docs/find/dual_number"><code>
              dual_number R</code></a></li>
          <li>Graded algebras: $A = \bigoplus_i A_i$ where $A_iA_j \subseteq A_{i+j}$
            <a href="https://leanprover-community.github.io/mathlib_docs/find/graded_algebra"><code>
              graded_algebra A</code></a></li>
        </ul>
      </section>
    </div>
  </div>
  <script src="reveal.js/dist/reveal.js"></script>
  <script src="reveal.js/plugin/highlight/highlight.js"></script>
  <script src="reveal.js/plugin/math/math.js"></script>
  <script src="reveal.js/plugin/notes/notes.js"></script>
  <script src="js/lean.min.js"></script>
  <script src="js/lean-goal.js"></script>
  <script src="js/vendor/Chart.min.js"></script>
  <script src="js/charts/cas.js"></script>
  <script src="js/charts/provers.js"></script>
  <script>
    Chart.defaults.global.defaultFontColor='black';
    Chart.defaults.global.defaultColor='black';
    Chart.defaults.global.defaultFontSize = 16;

    Reveal.initialize({
      mathjax3: {
        mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js',
        loader: {load: ['[tex]/mathtools']},
        tex: {
          packages: {'[+]': ['mathtools']},
        },
        chtml: {
          // This seems to break rendering on slides that weren't onscreen at render time
          // mtextInheritFont: true,
          mtextFont: 'Source Sans Pro',
        },
        options: {
          skipHtmlTags: {'[-]': ['code', 'pre']},
        },
      },
      plugins: [
        RevealHighlight,
        RevealMath.MathJax3,
        RevealNotes,
      ],
      history: true,
      center: true,
      // defaultTiming: 40,
      slideNumber: 'c/t',
      width: 1856,
      height: 1016,
      // showNotes: 'separate-page'
    });
  </script>
  <script src="js/inline_svg.js"></script>
</body>

</html>