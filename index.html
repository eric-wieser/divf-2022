<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="reveal.js/dist/reset.css" />
  <link rel="stylesheet" href="reveal.js/dist/reveal.css" />
  <link rel="stylesheet" href="reveal.js/dist/theme/white.css" />
  <link rel="stylesheet" href="css/hljs.css" />
  <link rel="stylesheet" href="css/common.css" />
  <link rel="shortcut icon" type="image/png" href="https://ericwieser.me/images/favicon.png"/>
  <meta name="author" content="Eric Wieser" />
  <meta name="description" content="
    Working with noncommutative algebras in computer algebra systems (CAS) can be challenging.
    Taking a popular CAS as an example; Python's sympy can run into various difficulties when working with the matrix and quaternion algebras, and building more unusual algebras only makes matters worse.
    While on the surface solving a similar class of problems to CAS, theorem provers offer a very strong correctness guarantee.
    As it turns out, the design decisions that ensure this guarantee are the same as those which provide the extensionality needed for adding new algebraic constructions.
    With this background, this talk acts as an introduction to the Lean theorem prover by example, and demonstrates some of the trade-offs to be made by choosing to use a theorem prover over a CAS.
    With the help of Lean's comprehensive library of formalized mathematics, Mathlib, I'll show how to manipulate and simplify some matrix expressions.
    Lean and Mathlib are a collaborative effort; this talk concludes with a summary of the more interesting parts I myself have contributed." />
  <meta name="keywords" content="sympy, lean, non-commutative algebra, mathlib" />
  <title>Non-commutative algebras, computer algebra systems, and theorem provers</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section class="center">
        <h1>Non-commutative algebras, computer algebra systems, and theorem provers</h1>

        <p>Eric Wieser<br/> Signal Processing Group</p>
        <small>slides: <a href="https://eric-wieser.github.io/divf-2022">
        eric-wieser.github.io/divf-2022</a></small>
        <small style="display: block; text-align: center; opacity: 0.5">2022-03-25</small>
        <aside class="notes">
          <p>Hi, I'm Eric Wieser, a PhD student at Cambridge University</p>
        </aside>
      </section>
      <section>
        <section class="center">
          <h2>Non-commutative algebras</h2>
        </section>
        <section>
          <h3><div class="parent-title"><span>Non-commutative algebras</span> Geometric motivation</div></h3>
          <div class="r-stretch" style="display: grid; align-items: center">
            <div class="grid" style="grid-template: auto / 1fr 1fr; text-align: left">
              <div>
                <p>Geometry is inherently non-commutative:</p>
                <ul>
                  <li>applying 3D rotations in a different order gives a different result</li>
                  <li>the oriented plane spanning $u$ and $v$ faces the opposite way to the one spanning $v$ and $u$</li>
                </ul>
              </div>
              <div>
                <p>&hellip; algebraic representations of geometry are too:</p>
                <ul>
                  <li>for rotation matrices, composition is multiplication, and $R_1R_2 \ne R_2R_1$ in general<br /></li>
                  <li>the normal vector of such a plane (in 3D) can be found with the cross product, and $u\times v = -v\times u$.</li>
                </ul>
              </div>
            </div>
          </div>
          <p style="text-align: left">
            The matrix algebra $\mathbb{R}^{n \times n}$ is the typical choice for representing geometry, but is by no means the only choice available:
          </p>
          <div class="grid" style="grid-template: 1fr / auto auto auto">
            <p>Quaternions</p>
            <p>Exterior powers</p>
            <p>Geometric Algebra</p>
          </div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Non-commutative algebras</span> Geometric examples</div></h3>
          <h4>Quaternions, $\mathbb{H}$</h4>
          <div style="text-align: left; margin-left: auto; margin-right: auto;" class="fragment">
            <p>Like the complex numbers, $q = r + x\mathrm{i} + y\mathrm{j} + z\mathrm{k}$, but with $i^2 = j^2 = k^2 = ijk = −1$.</p>
            <p>In 3D, a rotation around the axis $u$ by $\theta$ can be represented as:</p>
            $$e^{\frac{\theta}{2}{(u_x\mathrm{i} + u_y\mathrm{j} + u_z\mathrm{k})}} = \cos \frac{\theta}{2} + (u_x\mathrm{i} + u_y\mathrm{j} + u_z\mathrm{k}) \sin \frac{\theta}{2}$$
            <p>Applying a quaternion rotation is done as $qvq^{-1}$.</p>
            <p>A division ring, unlike the matrix algebra; all non-zero quaternions have an inverse.</p>
          </div>
          <div class="grid" style="grid-template: min-content auto / auto auto">
            <h4>Exterior&nbsp;algebra, $\bigwedge(V)$</h4>
            <h4>Geometric&nbsp;algebra, $\mathcal{G}(Q)$</h4>
            <div style="text-align: left" class="fragment">
              <p>For an arbitrary vector space $V$ containing $u, v$, $u \wedge v = -v \wedge u$ represents an oriented plane at the origin spanning $u$ then $v$.</p>
              <p>Unlike the cross product, generalizes to higher dimensions: $u \wedge v \wedge w$ is an oriented volume.</p>
            </div>
            <div style="text-align: left" class="fragment">
              <p>An extension of exterior algebra that includes a metric $Q$, which result in a dot product.</p>
              <p>Multiplication of vectors satisfies:</p>
              $$uv = u\cdot v + u \wedge v$$
            </div>
          </div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Non-commutative algebras</span>Weaker algebraic structures</div></h3>
          <div class="grid" style="grid-template-columns: min-content auto">
            <div style="text-align: right"><p>$ab \ne ba$</p></div>
            <div style="text-align: left">
              <p>Non-commutative multiplication is an example of a <q>weakening</q> of our algebraic rules that's particularly easy to motivate through geometry.</p>
            </div>
            <div style="text-align: right" class="fragment" data-fragment-index="0"><p>$ a \ne 0, b \ne 0, ab = 0$</p></div>
            <div style="text-align: left" class="fragment" data-fragment-index="0">
              <p>Some algebras, including $\mathbb{R}^{n \times n}$ and $\bigwedge(B)$ and $\mathcal{G}(Q)$, have <q>zero divisors</q>.</p>
              <p>This means $ab = ac \centernot\implies b = c$!</p>
            </div>
            <div style="text-align: right" class="fragment" data-fragment-index="1"><p>$a(bc) \ne (ab)c$</p></div>
            <div style="text-align: left" class="fragment" data-fragment-index="1">
              <p>Non-associative multiplication is fairly common too, for instance the vector cross product:</p>
              $$u \times (v \times w) = (u \times v) \times w + v \times (u \times w)$$
              <p>More examples: Lie algebras, Octonions, &hellip;</p>
            </div>
          </div>
          <div class="r-stretch"></div>
          <div class="fragment" data-fragment-index="2">
            <h3>This talk</h3>
            <div style="width: auto; margin: auto; text-align: left; display: table">
              <p>What software tools can aid us with algebra?</p>
              <p>Can they cope with these weaker algebraic structures?</p>
              <p>Is the way they handle matrices generalizable to other algebras of interest?</p>
            </div>
          </div>
        </section>
      </section>
      <section>
        <section>
          <h2>Computer algebra systems</h2>
          <blockquote>
            A computer algebra system (CAS) or symbolic algebra system (SAS) is any mathematical software with the ability to manipulate mathematical expressions in a way similar to the traditional manual computations of mathematicians and scientists.
            <p class="reference">
              <cite><a href="https://en.wikipedia.org/wiki/Computer_algebra_system">Computer algebra system</a></cite>
              <span>Wikipedia</span>
            </p>
          </blockquote>
          <div style="display: grid; grid-template: auto / auto auto; column-gap: var(--r-block-margin)">
            <div>
              <p>Useful for</p>
              <ul>
                <li>Roughly checking your work</li>
                <li>Answering what-if questions experimentally</li>
                <li>Solving large but tedious equations quickly</li>
                <li>&hellip;</li>
              </ul>
            </div>
            <div>
              <p>Typical features</p>
              <ul>
                <li>Algebraic simplification</li>
                <li>Root finding</li>
                <li>Integration and differentiation</li>
                <li>Arbitrary precision calculations</li>
                <li>&hellip;</li>
              </ul>
            </div>
          </div>
          <div class="fragment">
            <p>Notable implementations</p>
            <div style="height:50px; position:relative; width: 90%; margin: auto; margin-bottom: 20px">
              <canvas id="cas-timeline"></canvas>
            </div>
            <ul style="columns: 3; list-style-type: none">
              <li>Axiom (1965, BSD License)</li>
              <li style="text-align: right">Maxima (1982, GPL License)</li>
              <li>Maple (1982, Proprietary)</li>
              <li style="text-align: right">Magma (1993, Proprietary) </li>
              <li>Mathematica (1998, Proprietary)</li>
              <li style="text-align: right">SageMath (2004, GPL)</li>
            </ul>
          </div>
        </section>
        <section>
          <h2>Sympy</h2>
          <blockquote>
            SymPy is a Python library for symbolic mathematics. It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python.
            <p class="reference">
              <cite><a href="https://www.sympy.org/en/index.html">SymPy's website</a></cite>
              <!-- <span>Sympy.org</span> -->
            </p>
          </blockquote>
          <p class="fragment" style="text-align: center">Why wasn't this on the previous slide?</p>
          <blockquote class="fragment">
            Sage[Math] tries to gather together all the major open source mathematics software, and glue it together into a useful system. In fact, Sage[Math] includes SymPy as one of its systems.
            <p class="reference">
              <cite><a href="https://stackoverflow.com/q/17847902/102441">What is the difference between SymPy and Sage[Math]?</a></cite>
              <span>Aaron Meurer (Lead SymPy developer)</span>
            </p>
          </blockquote>
        </section>
        <section>
          <h3><div class="parent-title"><span>Sympy</span> Examples</div></h3>
          <div class="r-stretch" style="display: grid; align-items: center">
            <blockquote>
              <div class="grid" style="grid-template: auto auto / 1fr 1fr; align-items: end; margin-bottom: 0">
                <div>
                  <p>Take the derivative of $\sin{(x)}e^x$</p>
                  <pre><code class="pycon" data-trim data-no-escape>
                  &gt;&gt;&gt; diff(sin(x)*exp(x), x)
                  $e^{x} \sin{\left(x \right)} + e^{x} \cos{\left(x \right)}$
                  </code></pre>
                </div>
                <div>
                  <p>Compute $\int_{-\infty}^\infty \sin{(x^2)}\,dx$</p>
                  <pre><code class="pycon" data-trim data-no-escape>
                  &gt;&gt;&gt; integrate(exp(x)*sin(x) + exp(x)*cos(x), x)
                  $e^{x} \sin{\left(x \right)}$
                  </code></pre>
                </div>
                <div>
                  <p>Solve $x^2 - 2 = 0$</p>
                  <pre><code class="pycon" data-trim data-no-escape>
                  &gt;&gt;&gt; solve(x**2 - 2, x)
                  $\left[ - \sqrt{2}, \  \sqrt{2}\right]$
                  </code></pre>
                </div>
                <div>
                  <p>Solve the differential equation $y'' - y = e^t$</p>
                  <pre><code class="pycon" data-trim data-no-escape>
                    &gt;&gt;&gt; y = Function('y')
                    &gt;&gt;&gt; dsolve(Eq(y(t).diff(t, t) - y(t), exp(t)), y(t))
                    $y{\left(t \right)} = C_{2} e^{- t} + \left(C_{1} + \frac{t}{2}\right) e^{t}$
                  </code></pre>
                </div>
              </div>
              <p class="reference">
                <cite><a href="https://docs.sympy.org/latest/tutorial/intro.html#the-power-of-symbolic-computation">
                  The Power of Symbolic Computation
                </a></cite>
                <span>SymPy.org</span>
              </p>
            </blockquote>
          </div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Sympy</span>Expression trees</div></h3>
          <pre><code class="pycon" data-trim>
          >>> from sympy import *; from this_presentation import show_repr
          </code></pre>
          <div style="display: grid; align-items: end; grid-template: auto auto / 1fr 1fr; column-gap: var(--r-block-margin)">
            <div class="fragment" data-fragment-index="1">
              <h4>Real numbers</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; x, y = symbols('x y', real=True)
              &gt;&gt;&gt; expr = (x + y)*(x - y); expr
              $(x - y)(x + y)$
              <span class="fragment" data-fragment-index="2">&gt;&gt;&gt; show_repr(expr)
              Mul(Add($x$, Mul(Integer(-1), $y$)),
                  Add($x$, $y$))</span>
              </code></pre>
            </div>
            <div class="fragment" data-fragment-index="3">
              <h4>Complex numbers</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; x, y = symbols('x y', complex=True)
              &gt;&gt;&gt; expr = (x + y)*(x - y); expr
              $(x - y)(x + y)$
              <span class="fragment" data-fragment-index="4">&gt;&gt;&gt; show_repr(expr)
              Mul(Add($x$, Mul(Integer(-1), $y$)),
                  Add($x$, $y$))</span>
              </code></pre>
            </div>
            <div class="fragment" data-fragment-index="5">
              <h4>Matrices</h4>
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; m, n = symbols('m n')
              &gt;&gt;&gt; X = MatrixSymbol('X', m, n)
              &gt;&gt;&gt; Y = MatrixSymbol('Y', m, n)
              &gt;&gt;&gt; expr = (X + Y)*(X - Y).T; expr
              $(X + Y)(X^T - Y^T)$
              <span class="fragment" data-fragment-index="6">&gt;&gt;&gt; show_repr(expr)
              MatMul(MatAdd($X$, $Y$),
                     MatAdd(Transpose($X$),
                            MatMul(Integer(-1), Transpose($Y$))))</span>
              </code></pre>
            </div>
            <div>
              <div style="text-align: center" class="fragment" data-fragment-index="2">
                Underlying representations
              </div>
              <div style="display: table;">
                <div style="display: table-row" class="fragment" data-fragment-index="2">
                  <span style="display: table-cell; text-align: right">Real:&nbsp;</span>
                  <span style="display: table-cell; text-align: left">
                    <code>Symbol</code>, <code>Add</code>, <code>Mul</code>, &hellip;</span></div>
                <div style="display: table-row" class="fragment" data-fragment-index="4">
                  <span style="display: table-cell; text-align: right">Complex:&nbsp;</span>
                  <span style="display: table-cell; text-align: left">
                    <code>Symbol</code>, <code>Add</code>, <code>Mul</code>, &hellip;</span></div>
                <div style="display: table-row" class="fragment" data-fragment-index="6">
                  <span style="display: table-cell; text-align: right">Matrix:&nbsp;</span>
                  <span style="display: table-cell; text-align: left">
                    <code>MatrixSymbol</code>, <code>MatrixAdd</code>, <code>MatrixMul</code>, &hellip;</span></div>
                <div style="display: table-row" class="fragment" data-fragment-index="7">
                  <span style="display: table-cell; text-align: right">Quaternion:&nbsp;</span>
                  <span style="display: table-cell; text-align: left">
                  &hellip;</span></div>
              </div>
            </div>
          </div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Sympy</span>Expression trees</div></h3>
          <div>
            <h4>Quaternions</h4>
            <p>No symbolic quaternions; only quaternions with symbolic coefficients.</p>
            <pre><code class="pycon" data-trim data-noescape>
            &gt;&gt;&gt; x, xi, xj, xk = symbols('x x_i x_j x_k');  xq = Quaternion(x, xi, xj, xk)
            &gt;&gt;&gt; y, yi, yj, yk = symbols('y y_i y_j y_k');  yq = Quaternion(y, yi, yj, yk)
            &gt;&gt;&gt; expr = xq * yq; expr
            $\left(x y - x_{i} y_{i} - x_{j} y_{j} - x_{k} y_{k}\right) + \left(x y_{i} + x_{i} y + x_{j} y_{k} - x_{k} y_{j}\right) i + \left(x y_{j} - x_{i} y_{k} + x_{j} y + x_{k} y_{i}\right) j + \left(x y_{k} + x_{i} y_{j} - x_{j} y_{i} + x_{k} y\right)$
            <span class="fragment">&gt;&gt;&gt; show_repr(expr)
            Quaternion(Add(Mul($x$, $y$), Mul(Integer(-1), $x_i$, $y_i$), Mul(Integer(-1), $x_j$, $y_j$), Mul(Integer(-1), $x_k$, $y_k$)),
                       Add(Mul($x$, $y_i$), Mul($x_i$, $y$), Mul($x_j$, $y_k$), Mul(Integer(-1), $x_k$, $y_j$)),
                       Add(Mul($x$, $y_j$), Mul(Integer(-1), $x_i$, $y_k$), Mul($x_j$, $y$), Mul($x_k$, $y_i$)),
                       Add(Mul($x$, $y_k$), Mul($x_i$, $y_j$), Mul(Integer(-1), $x_j$, $y_i$), Mul($x_k$, $y$)))</span>
            </code></pre>
          </div>
          <p class="fragment">This makes quaternions hard to work with:</p>
          <div class="grid" style="grid-template: auto / auto auto; align-items: end">
            <div class="fragment">
              <pre><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; (xq * xq * xq**-1 * yq).simplify()
              <div style="font-size: 75%; line-height: 1.3em">$\left(x y - x_{i} y_{i} - x_{j} y_{j} - x_{k} y_{k}\right) + \left(x y_{i} + x_{i} y + x_{j} y_{k} - x_{k} y_{j}\right) i$
              $\qquad + \left(x y_{j} - x_{i} y_{k} + x_{j} y + x_{k} y_{i}\right) j + \left(x y_{k} + x_{i} y_{j} - x_{j} y_{i} + x_{k} y\right) k$</div>
              </code></pre>
              <p>(would prefer $x_qx_qx_1^{-1}y_q = x_qy_q$)</p>
            </div>
            <div class="fragment">
              <pre style="font-size: 60%"><code class="pycon" data-trim data-noescape>
              &gt;&gt;&gt; def q_diff(p, dq):  # like ∇Φ, but for Φ taking quaternions
              ...     I, J, K = Quaternion(0,1,0,0), Quaternion(0,0,1,0), Quaternion(0,0,0,1)
              ...     return p.diff(dq.a) + I*p.diff(dq.b) + J*p.diff(dq.c) + K*p.diff(dq.d)
              &gt;&gt;&gt; q_diff(xq*yq, xq)
              $- 2 y + - 2 y_{i} i + - 2 y_{j} j + - 2 y_{k} k$
              </code></pre>
              <p>(would prefer $\nabla_{x_q}(x_qy_q) = -2y_q$)</p>
            </div>
          </div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Sympy</span>Examples with matrix determinants</div></h3>
          <div class="grid" style="grid-template: auto / auto auto auto;">
            <div>
              <pre><code class="pycon" data-trim>
              >>> m, n = symbols('m, n')
              </code></pre>
            </div>
            <div>
              <pre><code class="pycon" data-trim>
              >>> A = MatrixSymbol('A', n, n)
              >>> B = MatrixSymbol('B', n, n)
              </code></pre>
            </div>
            <div>
              <pre><code class="pycon" data-trim>
              >>> P = MatrixSymbol('P', m, n)
              >>> Q = MatrixSymbol('Q', n, m)
              </code></pre>
            </div>
          </div>
          <div class="grid" style="grid: auto auto auto / 1fr 2fr; align-items: end;">
            <div data-fragment-index="0" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} AB = \operatorname{det} A \operatorname{det} B$$
              <pre><code class="pycon" data-trim>
              >>> Eq(det(A*B), det(A)*det(B))
              $\text{True}$
              </code></pre>
            </div>
            <div data-fragment-index="0"  class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code class="python">Eq</code> can be used to write down a symbolic equality.</p>
              <p><code>sympy</code> is automatically performing this simplification for us, via <code class="python">MatMul._eval_determinant</code>.</p>
            </div>
            <div data-fragment-index="1"  class="fragment fade-in-then-semi-out">
              $$\operatorname{det} ABA^{-1} = \operatorname{det} B$$
              <pre><code class="pycon" data-trim>
              >>> Eq(det(A*B*A.inv()), det(B))
              $\left|{A^{-1}}\right| \left|{A}\right| \left|{B}\right| = \left|{B}\right|$
              >>> Eq(det(A*B*A.inv()), det(B)).simplify()
              $\text{True}$
              </code></pre>
            </div>
            <div data-fragment-index="1" class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code class="python">MatMul._eval_determinant</code> gets us partway there, but doesn't finish the job.</p>
              <p><code class="python">simplify()</code> can clean up.</p>
            </div>
            <div data-fragment-index="2" class="fragment">
              $$\operatorname{det} (I_m + PQ) = \operatorname{det} (I_n + QP)$$
              <pre class="r-stack"><code class="pycon fragment" data-trim data-fragment-index="2" >
              >>> I = Identity
              >>> Eq(det(I(m) + P*Q), det(I(n) + Q*P))
              $\left|{\mathbb{I} + PQ}\right| = \left|{\mathbb{I} + QP}\right|$
              >>> Eq(det(I(m) + P*Q), det(I(n) + Q*P)).simplify()
              NonSquareMatrixError: Det of a non-square matrix
              </code><code class="pycon fragment" data-trim data-noescape data-fragment-index="3">
              &gt;&gt;&gt; I = Identity
              &gt;&gt;&gt; Eq(det(I(<b>n</b>) + A*B), det(I(n) + B*A))
              $\left|{\mathbb{I} + AB}\right| = \left|{\mathbb{I} + BA}\right|$
              &gt;&gt;&gt; Eq(det(I(<b>m</b>) + A*B), det(I(n) + B*A)).simplify()
              AttributeError: 'Mul' object has no attribute
                'shape'
              </code></pre>
            </div>
            <div data-fragment-index="2" class="fragment" style="text-align: left">
              <p>(sometimes called the <q>Weinstein–Aronszajn</q> identity)</p>
              <p>There is no <code class="python">MatAdd._eval_determinant</code> to help here, it wouldn't generalize well anyway.</p>
              <p>Simplification is ad-hoc, and sometimes crashes! Switching to square matrices makes things worse</p>
            </div>
          </div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Sympy</span>What's going wrong?</div></h3>
          <p>Let's imagine we want to support a new algebra, <code>MyAlg</code>. We have two big hurdles:</p>
          <div class="r-stretch" style="display: grid; align-items: center">
            <div class="grid" style="grid-template-columns: 1fr 1fr">
              <div class="fragment">
                <h4 style="margin-top: var(--r-block-margin)">Extending the expression tree</h4>
                <div style="text-align: left">
                  <p>It looks like we have to build new <code>MyAlgAdd</code>, <code>MyAlgMul</code>, &hellip; objects.</p>
                  <p>This scales poorly if we want to work with things like matrices of <code>MyAlg</code>; do we need <code>MatrixMyAlgAdd</code> e.t.c.?</p>
                  <p>If we get this wrong, things like <code>simplify()</code> fail if they expect <code>MyMul</code> but get an <code>Mul</code>.</p>
                </div>
              </div>
              <div class="fragment">
                <h4 style="margin-top: var(--r-block-margin)">Supporting symbols</h4>
                <div style="text-align: left">
                  <p>It's not enough to define our objects as simple structures with fields like <code>Quaternion</code>, like we would in a conventional programming language.</p>
                  <p>Every one of our expression tree objects needs to know how to simplify itself.</p>
                  <p>This scales poorly to compound expressions like $\operatorname{det}(1 + AB) = \operatorname{det}(1 + BA)$, where simplification only makes sense globally.</p>
                  <p><strong>We're responsible for verifying that our simplifications are mathematically sound!</p></strong>
                </div>
              </div>
            </div>
          </div>
          <p class="fragment">What if our programming language could handle all of these things for us?</p>
        </section>
      </section>
      <section>
        <h2>Theorem proving languages - History</h2>
        <div style="height:50px; position:relative; width: 90%; margin: auto; margin-bottom: 20px">
          <canvas id="lean-timeline"></canvas>
        </div>
        <ul>
          <li class="fragment">Relatively new (compared to other actively used tools)
            <ul>
              <li style="font-size: smaller">Mizar (<span style="color: #42affa">1973</span>), Isabelle (<span style="color: #42affa">1986</span>), HOL Family (<span style="color: #42affa">1988</span>)</li>
              <li style="font-size: smaller">Coq (<span style="color: #42affa">1989</span>), Metamath (<span style="color: #42affa">1993</span>), Agda (<span style="color: #42affa">2007</span>)</li>
              <li style="font-size: smaller">Lean 1 (<span style="color: green">2013</span>) & Lean 2 (<span style="color: green">2015</span>)</li>
            </ul>
            <blockquote>
              Lean had the advantage of being born later and learning from past mistakes.
              <p class="reference">
                <cite>CICM 2020 slack</cite>
                <span>Mario Carneiro, Lean Maintainer</span>
              </p>
            </blockquote>
          </li>
          <li class="fragment">Lean 3 (<span style="color: green">2016</span>)
            <ul>
              <li style="font-size: smaller">Actively maintained by the community (v3.24.0 to v3.35.1 in 2021)</li>
              <li style="font-size: smaller">Can be used <a href="https://leanprover.github.io/live/latest/">in-browser</a> or in supported IDEs: <a href="https://github.com/leanprover/vscode-lean">VS Code</a> and <a href="https://github.com/leanprover/lean-mode">Emacs</a></li>
            </ul>
          </li>
          <li class="fragment">Lean 4 (<span style="color: orange">202x</span>)
            <ul>
              <li style="font-size: smaller">Better support for domain-specific syntax and custom automation</li>
              <li style="font-size: smaller">Native code and its formal verification in one language</li>
              <li style="font-size: smaller">In active development at Microsoft Research</li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
        <section>
          <h3><div class="parent-title"><span>Lean in Practice</span> Definitions, Types, and Terms</div></h3>
          <pre style="font-size: 1em; display: inline-grid"><code class="lean" data-trim data-noescape>
            <span class="fragment" data-fragment-index="0">-- name : type := value (or "term")
            def two : ℕ := 2</span>

            <span class="fragment" data-fragment-index="1">def double : ℕ → ℕ :=
            λ a, two * a</span>

            <span class="fragment" data-fragment-index="2">def unlikely : Prop := ∃ x : ℕ, x*x = 2</span>
            <span class="fragment" data-fragment-index="3">lemma unlikely_proof : unlikely := sorry</span>

            <span class="fragment" data-fragment-index="4">lemma double_is_add_self : ∀ a : ℕ, double a = a + a :=</span>
            <span class="fragment" data-fragment-index="5">by { intro a, apply two_mul }</span>
          </code></pre>
          <div class="r-stack">
            <div class="fragment current-only" data-fragment-index="0">
              Lean tries to resemble the math, <code>ℕ = nat</code>.
              <blockquote style="width: 60%">
                mathematicians [have] lower tolerance for unintuitive interfaces than computer scientists.
                <p class="reference">
                  <cite>CICM 2020 slack</cite>
                  <span>Mario Carneiro, PhD in Logic, Lean Maintainer</span>
                </p>
              </blockquote>
            </div>
            <div class="fragment current-only" data-fragment-index="1">
              <code>→</code> declares a function type.<br />
              <code>λ</code> creates a function <i>term</i>.
            </div>
            <div class="fragment current-only" data-fragment-index="2">
              A <code>Prop</code> is a mathematical statement
            </div>
            <div class="fragment current-only" data-fragment-index="3">
              <p><code>Prop</code> instances are themselves <code>Type</code>s.</p>
              <p>Values are their proofs.</p>
            </div>
            <div class="fragment current-only"  data-fragment-index="4">
              <p>Note that <code>a</code> is analogous to a <code>sympy.Symbol</code> here</p>
              <p>Symbols in mathematical statements are the same thing as function arguments!</p>
              <p><code>double_is_add_self 1</code> is a proof that <code>double 1 = 1 + 1</code></p>
            </div>
            <div class="fragment current-only"  data-fragment-index="5">
              <code>intro</code> and  <code>apply</code> are tactics,<br />
              to help us construct proofs interactively
            </div>
          </div>
          <div class="r-stretch"></div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Lean in Practice</span> <code>class</code> for abstraction</div></h3>
          <pre style="font-size: 1em; display: inline-grid"><code class="lean" data-trim data-noescape>
            <span class="fragment" data-fragment-index="0">class add_comm_group (A : Type)</span>
            <span class="fragment" data-fragment-index="1">  extends has_add A, has_zero A, has_neg A : Type :=</span>
            <span class="fragment" data-fragment-index="2">(add_comm     : ∀ a b : A,         a + b = b + a      )
            (add_assoc    : ∀ a b c : A, (a + b) + c = a + (b + c))
            (zero_add     : ∀ a : A,           0 + a = a          )
            (add_one      : ∀ a : A,           a + 0 = a          )
            (add_left_neg : ∀ a : A,          -a + a = 0          )</span>
          </code></pre>
          <div class="r-stack">
            <div class="fragment current-only" data-fragment-index="0">
              <p><code>add_comm_group</code> is the name of our type-class.</p>
              <p>
                <code>A</code> makes this a dependent type,<br />
                <code>add_comm_group A</code> is a collection of proofs that <code>A</code> forms an abelian <code>group</code>.</p>
            </div>
            <div class="fragment current-only" data-fragment-index="1">
              <p><code>extends</code> is inheritance.</p>

              <p>Used here to provide <code>+</code>, <code>0</code> and <code>-</code> for <code>A</code>.</p>
            </div>
            <div class="fragment current-only" data-fragment-index="2">
              The usual abelian group axioms, as fields which hold proofs.
            </div>
            <div class="fragment" data-fragment-index="3">
              <div>
                Type classes form an API
              </div>
              <div class="grid" style="grid-template-columns: 1fr 1fr">
                <div class="fragment"  data-fragment-index="4">
                  <p>Proofs working over an abelian group <i>use</i> the API,
                  and generalize to <i>all</i> abelian groups...</p>
                  <pre><code class="lean" data-trim>
                  lemma neg_add {A : Type u} [add_comm_group A]
                    (a b : G) : -(a + b) = -a + -b := sorry
                  </code></pre>
                </div>
                <div class="fragment" data-fragment-index="5">
                  <p>Showing $\mathbb{H}$ is an abelian group means <i>implementing</i> the API:</p>
                  <pre><code class="lean" data-trim>
                  instance : add_comm_group ℍ :=
                  { add_assoc := sorry, add_comm := sorry,
                    zero_add := sorry,  add_zero := sorry,
                    add_left_neg := sorry }
                  </code></pre>
                </div>
              </div>
            </div>
          </div>
          <div class="r-stretch"></div>
        </section>
        <section id="matrix-determinant-lean">
          <h3><div class="parent-title"><span>Lean in Practice</span>Examples with matrix determinants</div></h3>
          <pre><code class="lean" data-trim>
            import linear_algebra.matrix.nonsingular_inverse
            variables {R m n : Type} [comm_ring R] [fintype m] [fintype n] [decidable_eq m] [decidable_eq n]
            variables (A B : matrix n n R) (P : matrix m n R) (Q : matrix n m R)
            open matrix         -- for `det`
            open_locale matrix  -- for `⬝`
          </code></pre>
          <div style="display: grid; grid: auto auto auto / 1fr 2fr; align-items: end; column-gap: var(--r-block-margin)">
            <div data-fragment-index="0" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} AB = \operatorname{det} A \operatorname{det} B$$
              <pre><code class="lean" data-trim>
              example : det (A⬝B) = det A * det B :=
              by simp
              </code></pre>
            </div>
            <div data-fragment-index="0"  class="fragment fade-in-then-semi-out" style="text-align: left">
              <p><code>⬝</code> is matrix multiply.</p>
            </div>
            <div data-fragment-index="6" class="fragment semi-fade-out">
              <div class="fragment" data-fragment-index="1">
                $$\operatorname{det} ABA^{-1} = \operatorname{det} B$$
                <pre class="r-stack"><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="1">
                  example : det (A⬝B⬝A⁻¹) = det B :=
                  sorry
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="2">
                  example (hA : is_unit A) : det (A⬝B⬝A⁻¹) = det B :=
                  sorry
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="3">
                  example (hA : is_unit A) : det (A⬝B⬝A⁻¹) = det B :=
                  by <span class="error" title="⊢ A.det * B.det * ring.inverse A.det = B.det">simp [hA]<!--
                  --></span>
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="4">
                  example (hA : is_unit A) : det (A⬝B⬝A⁻¹) = det B :=
                  by <span class="info" title="Try this: exact det_conj hA B">library_search<!--
                  --></span>
                </code><code class="lean fragment" data-trim data-noescape
                    data-fragment-index="5">
                  example (hA : is_unit A) : det (A⬝B⬝A⁻¹) = det B :=
                  by exact det_conj hA B
                </code></pre>
              </div>
            </div>
            <div data-fragment-index="6" class="fragment semi-fade-out" style="text-align: left">
              <p data-fragment-index="1" class="fragment">
                We need a proof that <code>A</code> is invertible, spelt <code>is_unit A</code></p>
              <p data-fragment-index="3" class="fragment"><code>simp</code> takes us to a dead end</p>
              <p data-fragment-index="5" class="fragment"><code>library_search</code> finds that Lean knows this result</p>
            </div>
            <div data-fragment-index="6" class="fragment fade-in-then-semi-out">
              $$\operatorname{det} (I_m + PQ) = \operatorname{det} (I_n + QP)$$
              <pre><code class="lean" data-trim data-noescape>
              example : det (1 + P⬝Q) = det (1 + Q⬝P) :=
              by <span class="error" title="(1 + P ⬝ Q).det = (1 + Q ⬝ P).det">simp</span>
              </code></pre>
            </div>
            <div data-fragment-index="6" class="fragment fade-in-then-semi-out" style="text-align: left">
              <p>Lean doesn't know this result yet; let's prove it!</p>
            </div>
          </div>
        </section>
        <section>
          <h3><div class="parent-title"><span>Lean in Practice</span>Proving the Weinstein–Aronszajn identity</div></h3>
          <p>How do we prove $\operatorname{det} (1 + PQ) = \operatorname{det} (1 + QP)$ by hand?</p>
          <div style="font-size: 80%">
            \begin{align}
              \operatorname{det}\begin{bmatrix}A & B \\ C & D\end{bmatrix}
              &= \operatorname{det} D \cdot \operatorname{det}(A - BD^{-1}C)
              &\implies \operatorname{det}\begin{bmatrix}I & -P \\ Q & I\end{bmatrix}
              &= \operatorname{det}(I - (-P)Q) = \operatorname{det}(I + PQ)
            \end{align}
          </div>
          <div style="font-size: 80%" class="fragment" data-fragment-index="0">
            \begin{align}
              \operatorname{det}\begin{bmatrix}A & B \\ C & D\end{bmatrix}
              &= \operatorname{det} A \cdot \operatorname{det}(D - CA^{-1}B)
              &\implies \operatorname{det}\begin{bmatrix}I & -P \\ Q & I\end{bmatrix}
              &= \operatorname{det}(I - Q(-P)) = \operatorname{det}(I + QP)
            \end{align}
          </div>
          <div style="display: grid; grid-template: auto / 1fr 1fr; column-gap: var(--r-block-margin); text-align: center">
            <div>(Standard result with schur complement)</div>
            <div>(Set $A = I$, $B=-P$, $C=Q$ and $D = I$)</div>
          </div>
          <div class="r-stretch"></div>
          <div class="fragment" data-fragment-index="1">
            <div class="lean-demo">
              <pre class="r-stack"><code class="lean" data-trim data-noescape>
                /-- The Weinstein–Aronszajn identity -/
                lemma matrix.det_one_plus_comm :
                  det (1 + P⬝Q) = det (1 + Q⬝P) :=
                <span class="fragment" data-fragment-index="3">begin
                  calc det (1 + P⬝Q) = det (from_blocks 1 (-P) Q 1) : _
                                 ... = det (1 + Q⬝P)                : _,
                  <span class="fragment" data-fragment-index="4">{ <span class="fragment" data-fragment-index="5">rewrite det_from_blocks_one₂₂,</span>
                    <span class="fragment" data-fragment-index="6">rewrite matrix.neg_mul,</span>
                    <span class="fragment" data-fragment-index="7">rewrite sub_neg_eq_add,</span> },
                  <span class="fragment" data-fragment-index="9">{ rw [det_from_blocks_one₁₁, matrix.mul_neg,
                        sub_neg_eq_add] },</span></span>
                end</span>
              </code></pre>
              <div class="lean-state">
                <pre class="r-stack fragment" data-fragment-index="1"><code class="lean-goal fragment"
                  data-trim data-fragment-index="1" data-noescape>
                  <span style="opacity: 0.5">R : Type
                  m : Type
                  n : Type
                  _inst_1: comm_ring R
                  _inst_2: fintype m
                  _inst_3: fintype n
                  _inst_4: decidable_eq m
                  _inst_5: decidable_eq n</span>
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="2">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="3">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (from_blocks 1 (-P) Q 1)

                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (from_blocks 1 (-P) Q 1) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="4">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (from_blocks 1 (-P) Q 1)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="5">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 - -P⬝Q)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="6">
                  P : matrix m n R
                  Q : matrix n m R
                  ⊢ det (1 + P⬝Q) = det (1 - -(P⬝Q))
                </code><code class="lean-goal fragment" data-trim data-fragment-index="7">
                  goals accomplished 🎉
                </code><code class="lean-goal fragment" data-trim data-fragment-index="8">
                  ⊢ det (from_blocks 1 (-P) Q 1) = det (1 + Q⬝P)
                </code><code class="lean-goal fragment" data-trim data-fragment-index="9">
                  goals accomplished 🎉
                </code></pre>
              </div>
            </div>
            <div class="r-stack">
              <span class="fragment current-only" data-fragment-index="1">
              State the lemma. Lean provides the goal view, reminding us what we know.</span>
              <span class="fragment current-only" data-fragment-index="2">
                Most of the goal view is noise, so let's cut to the signal</span>
              <span class="fragment current-only" data-fragment-index="3">
                Outline the proof using the <code class="hljs lean">calc</code> tactic. Each <code class="hljs lean">_</code> is a hole, leaving us with two goals (<code class="hljs-goal-sym">⊢</code>).</span>
              <span class="fragment current-only" data-fragment-index="4">
                We can use <code class="hljs lean">{}</code> braces to focus on just the first goal.</span>
              <span class="fragment current-only" data-fragment-index="5">
                Let's expand <code class="hljs lean">det (from_blocks ...)</code> around the bottom right, ...</span>
              <span class="fragment current-only" data-fragment-index="6">
                &hellip; push the negation outside the product, &hellip;</span>
              <span class="fragment current-only" data-fragment-index="7">
                &hellip; and cancel the negations. We're done!</span>
              <span class="fragment current-only" data-fragment-index="8">
                Now we can go back to the other goal. We can solve it the same way, &hellip;</span>
              <span class="fragment current-only" data-fragment-index="9">
                &hellip; but let's write it more concisely.</span>
            </div>
          </div>
        </section>
      </section>
      <section>
        <section class="center">
          <h2>Mathlib</h2>
        </section>
        <section>
          <h3>What does Mathlib know?</h3>
          <div style="text-align: left">
            <p>Of particular interest to engineers:</p>
            <ul>
              <li>Linear algebra
                <ul>
                  <li>Vector subspaces</li>
                  <li>Matrices</li>
                  <li>Eigenspaces</li>
                </ul></li>
              <li>Multivariate calculus
                <ul>
                  <li>Partial derivatives</li>
                  <li>Fourier series</li>
                </ul>
              </li>
              <li>Polynomials and power series</li>
              <li>Probability theory</li>
            </ul>
          </div>
        </section>
        <section id="mathlib-knows-parseval">
          <h3><div class="parent-title"><span>What does Mathlib know?</span>Parseval's theorem</div></h3>
          <div class="grid" style="grid-template: auto / 1fr 1fr">
            <blockquote>
              <p>These amplitudes [$c_n$] can be related to the power content of the signal $g(t)$ over one period</p>
              $$\sum_{n=-\infty}^{\infty}|c_n|^2 dt = \frac{1}{T}\int_{0}^{T}|g(t)|^2 dt$$
              <p style="text-align: center">where $g(t) = \sum_{n=-\infty}^{\infty}c_ne^{jn\omega_0t}$</p>
              <p class="reference">
                <cite><a href="http://teaching.eng.cam.ac.uk/content/engineering-tripos-part-ib-2p6-fourier-transforms-signal-and-data-analysis-2020-21">CUED IB Paper 6</a>, Handout 2, Lent 2021</cite>
                <span>S. Godsill</span>
              </p>
            </blockquote>
            <blockquote>
              The sum of the squared norms of the Fourier coefficients equals the $L^2$ norm of the function.
              <pre><code class="lean" data-trim>
                lemma tsum_sq_fourier_series_repr
                  (g : Lp ℂ 2 haar_circle) :
                    ∑' n : ℤ, ∥fourier_series.repr g n∥^2
                      = ∫ t : circle, ∥g t∥^2 ∂haar_circle :=
              </code></pre>
              <p class="reference">
                <cite><a href="https://leanprover-community.github.io/mathlib_docs/find/tsum_sq_fourier_series_repr">Fourier analysis on the circle</a></cite>
                <span>Mathlib docs</span>
              </p>
            </blockquote>
          </div>
          <div class="fragment">
            <p style="text-align: center">Some translation required!</p>
            <div style="display: grid; grid-template: auto auto auto auto / 1fr min-content 1fr; column-gap: 1em; text-align: left; margin-bottom: var(--r-block-margin)">
              <q style="text-align: right">one period</q> &leftrightarrow; <code>t : circle</code>
              <q style="text-align: right">$c_n$</q> &leftrightarrow; <code>fourier_series.repr g n</code>
              <q style="text-align: right">$\frac{1}{T}dt$</q> &leftrightarrow; <span>
                <code>∂haar_circle</code>
                <small style="display: block">(the <q>measure</q> around a circle that sums to 1)</small>
              </span>
              <q style="text-align: right">$g(t) = \sum \cdots$</q> &leftrightarrow; <span>
                <code class="lean">g : Lp ℂ 2 haar_circle</code>
                <small style="display: block">(<code class="lean">g</code> is a function of type <code>circle → ℂ</code>, with finite $L^2$ norm)</small>
              </span>
            </div>
          </div>
          <div class="r-stretch"></div>
        </section>
        <section id="mathlib-knows-cayley-hamilton">
          <h3><div class="parent-title"><span>What does Mathlib know?</span>The Cayley-Hamilton theorem</div></h3>
          <div class="grid" style="grid-template: auto / 1fr 1fr">
            <blockquote>
              The characteristic polynomial of $A$ is defined as
              \begin{align}
              p_{A}(\lambda)&=\det(\lambda I_{n}-A) \\
              \textit{[...]}\quad&=\lambda^{n}+c_{n-1}\lambda^{n-1}+\cdots+c_{1}\lambda+c_{0}
              \end{align}
              One can create an analogous polynomial $p_{A}(A)$ [...].
              The Cayley–Hamilton theorem states that $p_A(A) = 0$.
              <p class="reference">
                <cite><a href="https://en.wikipedia.org/wiki/Cayley%E2%80%93Hamilton_theorem">Cayley–Hamilton theorem</a></cite>
                <span>Wikipedia</span>
              </p>
            </blockquote>
            <blockquote>
              The characteristic polynomial of a matrix, applied to the matrix itself, is zero.
               This holds over any commutative ring.
              <pre><code class="lean" data-trim>
                lemma matrix.aeval_self_charpoly {R n : Type}
                  [comm_ring R] [decidable_eq n] [fintype n]
                  (A : matrix n n R) :
                    polynomial.aeval A A.charpoly = 0
              </code></pre>
              <p class="reference">
                <cite><a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.aeval_self_charpoly">Characteristic polynomials and the Cayley-Hamilton theorem</a></cite>
                <span>Mathlib docs</span>
              </p>
            </blockquote>
          </div>
          <div class="fragment" style="display: grid; grid-template: auto auto auto / 1fr min-content 1fr; column-gap: 1em; text-align: left; margin-bottom: var(--r-block-margin)">
            <q style="text-align: right">$p_A$</q> &leftrightarrow; <code>A.charpoly</code>
            <q style="text-align: right">$p(A)$</q> &leftrightarrow; <code>polynomial.aeval A p</code>
          </div>
          <div class="r-stretch"></div>
          <div class="fragment">
            <blockquote>
              <p>Note that by [the] Cayley-Hamilton theorem,
              $e^{A\tau} = I\alpha_0(\tau) + \cdots + A^{n-1}\alpha_{n-1}$</p>
              <p class="reference">
                <cite><a href="http://teaching.eng.cam.ac.uk/content/engineering-tripos-part-iia-3f2-systems-control-2021-22">3F2: Systems and Control</a>, Lecture 4: controllability</cite>
                <span>R. Sepulchre</span>
              </p>
            </blockquote>
            <p>Mathlib does not yet have this corollary, but it is close&hellip;</p>
          </div>
        </section>
        <section id="mathlib-knows-math">
          <div class="grid r-stretch" style="grid-template: min-content auto min-content / 1fr 1fr; height: 100%; margin-top: 0">
            <h3 style="grid-column: 1 / span 2; margin-bottom: 0"><div class="parent-title"><span>What does Mathlib know?</span>Half an Undergraduate Mathematics Degree</div></h3>
            <div class="scroll-container" style="margin-bottom: 0">
              <iframe style="height: 520vh; width: 100%; max-width: none; max-height: none" src="https://leanprover-community.github.io/undergrad.html" scrolling="no"></iframe>
              <div class="fragment" style="position: absolute; top: 170vh" data-fragment-index="0" data-scroll-into-view></div>
              <div class="fragment" style="position: absolute; top: 230vh" data-fragment-index="1" data-scroll-into-view></div>
              <div class="fragment" data-fragment-index="2" data-scroll-into-view></div>
            </div>
            <div class="scroll-container" style="margin-bottom: 0">
              <iframe style="height: 550vh; width: 100%; max-width: none; max-height: none" src="https://leanprover-community.github.io/undergrad_todo.html" scrolling="no"></iframe>
              <div class="fragment" style="position: absolute; top: 125vh" data-fragment-index="0" data-scroll-into-view></div>
              <div class="fragment" style="position: absolute; top: 185vh" data-fragment-index="1" data-scroll-into-view></div>
              <div class="fragment" style="position: absolute; top: 340vh" data-fragment-index="2" data-scroll-into-view></div>
            </div>
            <small><a href="https://leanprover-community.github.io/undergrad.html">
              leanprover-community.github.io/undergrad.html
            </a></small>
            <small><a href="https://leanprover-community.github.io/undergrad_todo.html">
              leanprover-community.github.io/undergrad_todo.html
            </a></small>
          </div>
        </section>
        <section id="mathlib-knows-spaghetti" data-background-iframe="https://eric-wieser.github.io/mathlib-import-graph?highlight=mathlib:linear_algebra.matrix.determinant" data-background-interactive>
        </section>

        <section id="mathlib-contributions">
          <h2>Contributions to mathlib</h2>
          <ul>
            <li>Exterior algebra: $\bigwedge(V)$.
              <a href="https://leanprover-community.github.io/mathlib_docs/find/exterior_algebra"><code>
                exterior_algebra R V</code></a></li>
            <li>Alternating maps: $F : V^n \to W$ where $v_i = v_j \implies F(\ldots, v_i, \ldots, v_j, \ldots) = 0$.
              <a href="https://leanprover-community.github.io/mathlib_docs/find/alternating_map"><code>
                alternating_map R V</code></a></li>
            <li>Clifford algebra: $\mathcal{C}\ell(Q)$
              <a href="https://leanprover-community.github.io/mathlib_docs/find/clifford_algebra"><code>
                clifford_algebra Q</code></a></li>
            <li>Dual numbers: $R[\varepsilon]$ or $x + \varepsilon y$, where $\varepsilon^2 = 0$
              <a href="https://leanprover-community.github.io/mathlib_docs/find/dual_number"><code>
                dual_number R</code></a></li>
            <li>Graded algebras: $A = \bigoplus_i A_i$ where $A_iA_j \subseteq A_{i+j}$
              <a href="https://leanprover-community.github.io/mathlib_docs/find/graded_algebra"><code>
                graded_algebra A</code></a></li>
          </ul>
        </section>
      </section>
    </div>
  </div>
  <script src="reveal.js/dist/reveal.js"></script>
  <script src="reveal.js/plugin/highlight/highlight.js"></script>
  <script src="reveal.js/plugin/math/math.js"></script>
  <script src="reveal.js/plugin/notes/notes.js"></script>
  <script src="js/lean.min.js"></script>
  <script src="js/lean-goal.js"></script>
  <script src="js/vendor/Chart.min.js"></script>
  <script src="js/charts/cas.js"></script>
  <script src="js/charts/provers.js"></script>
  <script>
    Chart.defaults.global.defaultFontColor='black';
    Chart.defaults.global.defaultColor='black';
    Chart.defaults.global.defaultFontSize = 16;

    Reveal.initialize({
      mathjax3: {
        mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js',
        loader: {load: ['[tex]/mathtools', '[tex]/centernot']},
        tex: {
          packages: {'[+]': ['mathtools', 'centernot']},
        },
        chtml: {
          // This seems to break rendering on slides that weren't onscreen at render time
          // mtextInheritFont: true,
          mtextFont: 'Source Sans Pro',
        },
        options: {
          skipHtmlTags: {'[-]': ['code', 'pre']},
        },
      },
      plugins: [
        RevealHighlight,
        RevealMath.MathJax3,
        RevealNotes,
      ],
      history: true,
      center: false,
      // defaultTiming: 40,
      slideNumber: 'c/t',
      width: 1856,
      height: 1016,
      // showNotes: 'separate-page'
    });

    Reveal.on('fragmenthidden', event => {
      var activeFragments = Reveal.getCurrentSlide().querySelectorAll('.current-fragment');
      var seen = new Set();
      Array.from(activeFragments).forEach(f => {
        if (f && f.hasAttribute('data-scroll-into-view')) {
          f.parentElement.scrollTop = f.offsetTop;
          seen.add(f.parentElement);
        }
      });
      event.fragments.forEach(f => {
        if (f.hasAttribute('data-scroll-into-view') && !seen.has(f.parentElement)) {
          f.parentElement.scrollTop = 0
        }
      });
    } );
    Reveal.on('fragmentshown', event => {
      event.fragments.forEach(f => {
        if (f.hasAttribute('data-scroll-into-view')) {
          f.parentElement.scrollTop = f.offsetTop;
        }
      });
    } );
  </script>
  <script src="js/inline_svg.js"></script>
</body>

</html>